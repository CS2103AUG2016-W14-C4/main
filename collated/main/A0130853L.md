# A0130853L
###### /java/seedu/taskitty/commons/events/model/ViewTypeChangedEvent.java
``` java
/** 
 * Indicates the viewType being filtered in the model has changed
 * */
public class ViewTypeChangedEvent extends BaseEvent {

    public final ViewCommand.ViewType viewType;
    LocalDate date;

    public ViewTypeChangedEvent(ViewCommand.ViewType viewType, LocalDate date){
        this.viewType = viewType;
        this.date = date;
    }
    
    public LocalDate getDate() {
    	return date;
    }
    @Override
    public String toString() {
    	if (date == null) {
    		return "currently viewing: " + viewType;
    	} else if (DateUtil.isToday(date)) {
    		return "currently viewing: today";
    	} else {
    		return "currently viewing: " + date.toString();
    	}
    }
}
```
###### /java/seedu/taskitty/commons/util/DateUtil.java
``` java
    public static LocalDate createCurrentDate() {
		DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
    	Date dateobj = new Date();
    	String date = df.format(dateobj);
    	return LocalDate.parse(date, TaskDate.DATE_FORMATTER);
	}  
    
    public static String createDefaultDateString() {
    	return createUISpecifiedDateString(createCurrentDate());
    }
    
    /**
     * For use by the status bar footer, it appends a "(today)" string behind if date == today.
     *
     */
    public static String createUISpecifiedDateString(LocalDate date) {
    	DateTimeFormatter df = DateTimeFormatter.ofPattern("dd MMM yyyy");
    	String dateString = date.format(df);
    	if (isToday(date)) {
    		dateString += " (Today)";
    	}
    	return dateString;
    	
    }
    /**
     * For use by the event card.
     *
     */
    public static String createDateString(LocalDate date) {
    	DateTimeFormatter df = DateTimeFormatter.ofPattern("d MMM yyyy");
    	String dateString = date.format(df);
    	return dateString;
    	
    }
    
    
    public static boolean isToday(LocalDate date) {
    	return date.equals(createCurrentDate());
    }
}
```
###### /java/seedu/taskitty/commons/util/TimeUtil.java
``` java
    /**
     * creates a current Time object for comparison with current time.
     * @return
     */
    public static LocalDateTime createCurrentTime() {
		return LocalDateTime.now();
	}
    
    /**
     * For use by the event card.
     *
     */
    public static String createTimeString(LocalTime time) {
    	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("h:mma");
    	String dateString = formatter.format(time);
    	return dateString;
    	
    }
}
```
###### /java/seedu/taskitty/logic/commands/DoneCommand.java
``` java
/**
 * Marks a task as done identified using it's last displayed index from the task manager.
 */
public class DoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_PARAMETER = COMMAND_WORD + " [index] [more indexes]...";
    public static final String MESSAGE_USAGE = "This command marks tasks in TasKitty as done, Meow!"
            + "\n[index] is the index eg. t1, d1, e1.";

    public static final String MESSAGE_MARK_TASK_AS_DONE_SUCCESS_HEADER = "%1$s" + " tasks marked as done: ";
    public static final String MESSAGE_DUPLICATE_MARK_AS_DONE_ERROR_HEADER = "These tasks has already been marked as done: ";
    
    private boolean hasInvalidIndex;  
    private boolean hasDuplicateMarkAsDoneTask;  
    private boolean hasDuplicateIndexesProvided;
    
    private final List<Pair<Integer, Integer>> listOfIndexes;
    
    private final String commandText;
    
    private int categoryIndex;
    private int targetIndex;
    private String currentTaskIndex;
    
    private UnmodifiableObservableList<ReadOnlyTask> lastShownList;
    private ArrayList<ReadOnlyTask> listOfTasksToMarkDone;
    private ReadOnlyTask taskToMark;
    
    private StringBuilder invalidIndexMessage;
    private StringBuilder duplicateMarkAsDoneMessage;
    private StringBuilder duplicateIndexesProvidedMessage;
    private StringBuilder resultMessage;
    
    
    public DoneCommand(List<Pair<Integer, Integer>> listOfIndexes, String commandText) {
        assert listOfIndexes != null;
        this.listOfIndexes = listOfIndexes;
        this.hasInvalidIndex = false;
        this.hasDuplicateMarkAsDoneTask = false;
        this.hasDuplicateIndexesProvided = false;
        this.commandText = commandText;
    }

    @Override
    public CommandResult execute() {
     
        initialiseMessageBuildersAndTasksToMarkList();
        evaluatePresenceOfErrors();
        
        String errorMessage = generateErrorMessage();
        if (errorMessage != null) { // there are errors
            return new CommandResult(errorMessage);
        }
                    
        try {
            executeMarkTasks();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (DuplicateMarkAsDoneException e) {
            assert false: "The target task should not be marked done";
        }
        return new CommandResult(generateSuccessMessage());
    }
    
    /**
     * This method evaluates each entered index for 3 types of errors: invalid index, duplicate mark as done,
     * and duplicate indexes entered, and then sets the relevant boolean variables as true accordingly.
     */
    private void evaluatePresenceOfErrors() {
        for (Pair<Integer, Integer> indexPair: listOfIndexes) {
            setRelevantIndexesAndList(indexPair);
            if (hasInvalidIndex()) {
                continue;                                
            }
            if (hasDuplicateMarkAsDone()) {
                continue;
            }
            evaluateHasDuplicateIndexes();     
        }
    }
    
    /**
     * This method initialises the error message builders for each of the possible error cases, as well as the success message
     * builder for the case of successful execution.
     * It also initialises an empty arraylist to store the tasks to be marked as done so as to iterate through them subsequently.
     */
    private void initialiseMessageBuildersAndTasksToMarkList() {
        listOfTasksToMarkDone = new ArrayList<ReadOnlyTask>();
        invalidIndexMessage = new StringBuilder(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX + ": ");
        duplicateMarkAsDoneMessage = new StringBuilder(MESSAGE_DUPLICATE_MARK_AS_DONE_ERROR_HEADER);
        duplicateIndexesProvidedMessage = new StringBuilder(Messages.MESSAGE_DUPLICATE_INDEXES_PROVIDED + ": ");
        resultMessage = new StringBuilder(String.format(MESSAGE_MARK_TASK_AS_DONE_SUCCESS_HEADER, listOfIndexes.size()));
    }
    
    /**
     * This method takes in the relevant index that is currently being evaluated and extracts the actual index of the task in the list in
     * each iteration of evaluation. It also targets the correct list out of the 3 lists.
     */
    private void setRelevantIndexesAndList(Pair<Integer, Integer> indexPair) {
        categoryIndex = indexPair.getKey();
        targetIndex = indexPair.getValue();
        assert categoryIndex >= 0 && categoryIndex < 3;
        
        currentTaskIndex = Task.CATEGORIES[categoryIndex] + targetIndex + " ";
        
        lastShownList = AppUtil.getCorrectListBasedOnCategoryIndex(model, categoryIndex);
    }
    
    /**
     * This method calls the model to mark the specified tasks as done and stores the command for usage during undo/redo.
     * @throws TaskNotFoundException
     * @throws DuplicateMarkAsDoneException
     */
    private void executeMarkTasks() throws TaskNotFoundException, DuplicateMarkAsDoneException {
        model.markTasksAsDone(listOfTasksToMarkDone);
        model.storeCommandInfo(COMMAND_WORD, commandText, listOfTasksToMarkDone);
    }
    
    /**
     * This method generates a string representing the collated lists of tasks that were successfully marked as done
     * built from the success message builder.
     */
    private String generateSuccessMessage() {
        resultMessage.delete(resultMessage.length() - 2, resultMessage.length());// remove the extra separator at the end
        return resultMessage.toString();     
    }
    
    /** This method generates an error message based on the truth values of the 3 boolean error variables.
     * If none of them are true, it means there are no errors detected and hence it returns null.
     * @return either the specific error message based on one of the boolean variables, or null.
     */
    private String generateErrorMessage() {
        if (hasInvalidIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return invalidIndexMessage.toString().trim();
        }
        
        if (hasDuplicateIndexesProvided) {
            indicateAttemptToExecuteIncorrectCommand();
            return duplicateIndexesProvidedMessage.toString().trim();
        }
        
        if (hasDuplicateMarkAsDoneTask) {
            return duplicateMarkAsDoneMessage.toString().trim();
        }
        
        return null; // no errors
    }
    
    /**
     * This method evaluates to true if an invalid index is detected, and false otherwise.
     * If true, it also appends the problematic task index to the message builder.
     */
    private boolean hasInvalidIndex() {
        if (lastShownList.size() < targetIndex) {
            invalidIndexMessage.append(currentTaskIndex);
            return hasInvalidIndex = true;                               
        }
        return false;
    }
    
    /**
     * This method evaluates to true if a task that has already been marked as done is being marked again, and false otherwise.
     * If true, it also appends the problematic task index to the message builder.
     */
    private boolean hasDuplicateMarkAsDone() {
        taskToMark = lastShownList.get(targetIndex - 1); 
        if (taskToMark.getIsDone()) {
            duplicateMarkAsDoneMessage.append(currentTaskIndex);
            return hasDuplicateMarkAsDoneTask = true;
        }
        return false;
    }
    
    /**
     *  This method checks if there are duplicate indexes that were entered by the user to mark as done.
     *  If there are, then it appends the duplicated index to the message builder.
     *  If not, it appends to the success message builder instead.
     */
    private void evaluateHasDuplicateIndexes() {
        if (!listOfTasksToMarkDone.contains(taskToMark)) {
            listOfTasksToMarkDone.add(taskToMark);
            resultMessage.append(taskToMark.getName() + ", ");
        } else {
            duplicateIndexesProvidedMessage.append(currentTaskIndex);
            hasDuplicateIndexesProvided = true;  
        }
    }
}
```
###### /java/seedu/taskitty/logic/commands/ViewCommand.java
``` java
/**
 * This command has 4 types of functionalities, depending on the following keyword that is entered.
 * Type 1: view DATE/today
 * Lists all events for the specified date, deadlines up to the specified date, and all todo tasks.
 * Type 2: view done
 * Lists all tasks that have been completed.
 * Type 3: view
 * Lists all upcoming and uncompleted tasks in the task manager.
 * Type 4: view all
 * Lists all tasks in the task manager.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_PARAMETER = COMMAND_WORD + " [DATE/done/all]";
    public static final String MESSAGE_USAGE = "This command shows upcoming tasks, Meow!\n"
            + " Use \"view [DATE]\" for dated tasks, \"view done\" for done tasks, \"view all\" for all tasks!";
    public static final String VIEW_ALL_MESSAGE_SUCCESS = "All tasks are listed, Meow!";
    private LocalDate date;
    public enum ViewType {
    	
        done("done"), // to differentiate between 4 types of command functionalities
        date("date"), 
        all("all"), 
        normal("default"); 
    	
        private String value;
        
        ViewType(String value) {
            this.value = value;
        }
        public String getValue() {
            return value;
        }
    	
        @Override
        public String toString() {
            return this.getValue();
        } 
    }
    private ViewType viewType;

    /**
     * Constructor for view done and view date command functionalities.
     * @param parameter must not be empty, and will definitely be "done", "all", 
     * or a valid date guaranteed by the command parser.
     */
    public ViewCommand(String parameter) {
        assert parameter !=null;
        switch (parameter) { 
    	    case "done": // view done tasks
    	        viewType = ViewType.done;
    	        break;
    	    case "all":
    	        viewType = ViewType.all;
    	        break;
    	    default: // view tasks based on date
    	        this.date = LocalDate.parse(parameter, TaskDate.DATE_FORMATTER);
    	        viewType = ViewType.date;
        }
    }
    
    /**
     * Views uncompleted and upcoming tasks, events and deadlines.
     */
    public ViewCommand() {
        this.viewType = ViewType.normal;
    }
    
    
    @Override
    public CommandResult execute() {
        switch(viewType) {
    	    case normal: // view uncompleted and upcoming tasks
    	        model.updateToDefaultList();
    	        return new CommandResult(getMessageForTaskListShownSummary(model.getTaskList().size()));
    	    case done: // view done
    	        model.updateFilteredDoneList();
    	        return new CommandResult(getMessageForTaskListShownSummary(model.getTaskList().size()));
    	    case all: // view all
    	        model.updateFilteredListToShowAll();
    	        return new CommandResult(VIEW_ALL_MESSAGE_SUCCESS);
    	    default: // view date 
    	        model.updateFilteredDateTaskList(date);
    	        return new CommandResult(getMessageForTaskListShownSummary(model.getTaskList().size()));
        }
    }
    
}
```
###### /java/seedu/taskitty/logic/Logic.java
``` java
    /** Returns the filtered list when the app first opens, such that only events from today onwards are shown */
	void initialiseList();

}
```
###### /java/seedu/taskitty/logic/LogicManager.java
``` java
    @Override
    public void initialiseList() {
    	model.updateToDefaultList();
    }
}
```
###### /java/seedu/taskitty/logic/parser/CommandParser.java
``` java
    /**
     * Parses arguments in the context of the view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String arguments) {
    	if (arguments.trim().isEmpty()) {
			return new ViewCommand(); // view all upcoming uncompleted tasks, events and deadlines
		}
    	if (arguments.trim().equals("done")) {
    		return new ViewCommand("done"); // view done command
    	}
    	if (arguments.trim().equals("all")) {
    		return new ViewCommand("all"); // view all command
    	}
		String[] details = extractTaskDetailsNatty(arguments);
		if (details.length!= 3) { // no date was successfully extracted
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
			        Command.MESSAGE_FORMAT + ViewCommand.MESSAGE_PARAMETER));
	    } else {
	        assert details[1] != null; // contains date
	        return new ViewCommand(details[1]);
	    }
	}

```
###### /java/seedu/taskitty/model/Model.java
``` java
    /** Updates the filter of the filtered task list to filter out tasks that are done*/
	void updateFilteredDoneList();

	/** Updates the filter of the filtered task list according to date specified*/
	void updateFilteredDateTaskList(LocalDate date);
	
	/** Updates the filter such that events from today onwards and all deadlines and tasks are shown*/
	void updateToDefaultList();
	
	/** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();

}
```
###### /java/seedu/taskitty/model/ModelManager.java
``` java
    @Override
    public synchronized void markTasksAsDone(List<ReadOnlyTask> taskList) throws UniqueTaskList.TaskNotFoundException, DuplicateMarkAsDoneException{
        for (ReadOnlyTask targetTask: taskList) {
            taskManager.markTaskAsDoneTask(targetTask);
        }
    	indicateTaskManagerChanged();
    }
    
    /**
     *  To indicate that the currently filtered list has changed.
     * @param a viewType object from the ViewCommand enum class ViewType.
     */
    private void indicateViewChanged(ViewCommand.ViewType viewType, LocalDate date) {
    	raise(new ViewTypeChangedEvent(viewType, date));
    }
    
```
###### /java/seedu/taskitty/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Set<String> keywords){
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
        indicateViewChanged(ViewCommand.ViewType.all, null);
    }
    
    @Override
    public void updateFilteredListToShowAll() {
        allTasks.setPredicate(null);
        filteredTodos.setPredicate(null);
        filteredDeadlines.setPredicate(null);
        filteredEvents.setPredicate(null);
        indicateViewChanged(ViewCommand.ViewType.all, null);
    }

    @Override
    public void updateFilteredDoneList() {
    	updateFilteredTaskList(new PredicateExpression(p -> p.getIsDone() == true));
    	indicateViewChanged(ViewCommand.ViewType.done, null);
    }
    
    /** 
     * Updates list to show uncompleted and upcoming tasks only.
     */
    @Override
    public void updateToDefaultList() {
    	allTasks.setPredicate(p -> !p.getIsDone() && (p.isTodo() || p.isDeadline() || isEventAndIsNotBeforeToday(p)));
    	filteredTodos.setPredicate(p -> !p.getIsDone());
    	filteredDeadlines.setPredicate(p -> !p.getIsDone());
    	filteredEvents.setPredicate(p -> !p.getIsDone() && isEventAndIsNotBeforeToday(p));
    	indicateViewChanged(ViewCommand.ViewType.normal, null);
    }
    
    /**
     * Updates list to show deadlines on and before the specified date and events within the date.
     */
	@Override
	public void updateFilteredDateTaskList(LocalDate date) {
		allTasks.setPredicate(p -> isDateRelevantDeadlinesAndEvents(p, date));
		filteredTodos.setPredicate(null);
		filteredDeadlines.setPredicate(p -> isDeadlineAndIsNotAfterDate(p, date));
		filteredEvents.setPredicate(p -> isEventAndDateIsWithinEventPeriod(p, date));
		indicateViewChanged(ViewCommand.ViewType.date, date);
	}
	
```
###### /java/seedu/taskitty/model/ModelManager.java
``` java
    /**
     * Evaluates if the task is a deadline and is not after the specified date.
     * @param task
     * @param date
     * @return the evaluated boolean expression
     */
    private boolean isDeadlineAndIsNotAfterDate(Task task, LocalDate date) {
		return task.isDeadline() && !task.getPeriod().getEndDate().getDate().isAfter(date);
	}
    
	/**
	 * Evaluates if the task is an event and the specified date is within the event period.
	 * @param a valid task in the task manager
	 * @param the date that the user requested to search for
	 * @return the evaluated boolean expression
	 */
	private boolean isEventAndDateIsWithinEventPeriod(Task task, LocalDate date) {
		boolean relEndDate = isEventAndIsNotBeforeDate(task, date);
		boolean relStartDate = isEventAndIsNotAfterDate(task, date);
		return relEndDate && relStartDate;
	}
	
	/**
	 * A helper method to shorten the evaluated boolean expression that is otherwise longer.
	 * Evaluates if the task is an event and event is from `date` onwards.
	 * @param a valid task in the task manager
	 *@return the evaluated boolean expression
	 */
	private boolean isEventAndIsNotBeforeDate(Task task, LocalDate date) {
		return task.isEvent() && !(task.getPeriod().getEndDate().getDate().isBefore(date));
	}
	
	/**
	 * A helper method to shorten the evaluated boolean expression that is otherwise longer.
	 * Evaluates if the task is an event and event is either on `date` or before it.
	 * @param a valid task in the task manager
	 *@return the evaluated boolean expression
	 */
	private boolean isEventAndIsNotAfterDate(Task task, LocalDate date) {
		return task.isEvent() && !(task.getPeriod().getStartDate().getDate().isAfter(date));
	}
	
	/** 
	 * Evaluates if the task is an event and event is from today onwards.
	 * @param a valid task in the task manager
	 *@return the evaluated boolean expression
	 */
	private boolean isEventAndIsNotBeforeToday(Task task) {
		LocalDate today = DateUtil.createCurrentDate();
		return isEventAndIsNotBeforeDate(task, today);
	}
	
	/** 
	 * Abstracted boolean expression method for filtering according to the function `view date`.
	 * @param a valid task in the task manager
	 * @param the date that the user requested to search for
	 * @return the combined boolean expression from the 3 respective task-derived expressions.
	 */
	private boolean isDateRelevantDeadlinesAndEvents(Task p, LocalDate date) {
		boolean todos = p.isTodo();
		boolean relDeadlines = isDeadlineAndIsNotAfterDate(p, date);
		boolean relEvents = isEventAndDateIsWithinEventPeriod(p, date);
		return todos || relDeadlines || relEvents;
	}
	
```
###### /java/seedu/taskitty/model/task/ReadOnlyTask.java
``` java
    boolean getIsDone();
    boolean isTodo();
    boolean isDeadline();
    boolean isEvent();
    boolean isOverdue();
	
```
###### /java/seedu/taskitty/model/task/Task.java
``` java
    /** 
     * Marks task as done or event as over.
     */
    public void markAsDone() {
    	if (!isDone) {
    		this.isDone = true;
    		this.isOverdue = false;
    	}
    }
    
    /**
     * Marks a deadline as overdue.
     */
    public void markAsOverdue() {
    	if (!isDone && !isOverdue) {
    		this.isOverdue = true;
    	}
    }
    
    
```
###### /java/seedu/taskitty/model/task/Task.java
``` java
	@Override
	public boolean getIsDone() {
		return isDone;
	}
	
	@Override
	public boolean isTodo() {
		return period.isTodo();
	}
	
	@Override
	public boolean isDeadline() {
		return period.isDeadline();
	}
	
	@Override
	public boolean isEvent() {
		return period.isEvent();
	}
	
	// only for deadlines
	@Override
	public boolean isOverdue() {
		return isOverdue;
	}
	
	
```
###### /java/seedu/taskitty/model/task/TaskPeriod.java
``` java
    public boolean isTodo() {
        return numArgs == Task.TASK_COMPONENT_COUNT;
    }
    
    public boolean isDeadline() {
        return numArgs == Task.DEADLINE_COMPONENT_COUNT;
    }
    
    public boolean isEvent() {
        return numArgs == Task.EVENT_COMPONENT_COUNT;
    }

```
###### /java/seedu/taskitty/model/task/UniqueTaskList.java
``` java
    /**
     * Signals that the done operation targeting a specified task in the list is a duplicate operation if the task has already been previously
     * marked as done.
     */
    public static class DuplicateMarkAsDoneException extends Exception {}

```
###### /java/seedu/taskitty/model/task/UniqueTaskList.java
``` java
    /** Marks the given task as done from the list.
     * 
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateMarkAsDoneException if specified task in list had already been marked as done previously.
     */
    public void mark(ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateMarkAsDoneException {
    	assert toMark != null;
    	if (toMark.getIsDone()) {
    		throw new DuplicateMarkAsDoneException();
    	}
    	final boolean taskFoundAndMarkedAsDone = internalList.remove(toMark);
    	Task editableToMark = (Task) toMark;
    	editableToMark.markAsDone();
    	try {
            addSorted(editableToMark);
        } catch (DuplicateTaskException e) {
            assert false: "Should not have duplicate task";
        }
    	if (!taskFoundAndMarkedAsDone) {
    		throw new TaskNotFoundException();
    	}
    }   
    
```
###### /java/seedu/taskitty/model/task/UniqueTaskList.java
``` java

    public ObservableList<Task> getInternalList() {
    	checkAndSetOverdue();
    	checkAndSetIsOverToday();
        return internalList;
    }
    
    /**
     * Returns the internal list, filtered to view only the specified type of Task
     * 
     * @param filter according to Task.
     */
    private void checkAndSetOverdue() {
    	boolean hasOverdue = false;    	
    	for (Task t: internalList) {
    		if (t.isDeadline() && !t.getIsDone()) {
    			if (isOverdue(t)) {
    				t.markAsOverdue();
    				hasOverdue = true;
    			}
    		}
    	}
    	if (hasOverdue) {
    		ResultDisplay.setOverdue();
    	}
    }
    
    /**
     * When an event is over, automatically mark it as done.
     */
    private void checkAndSetIsOverToday() {
        final ArrayList<Task> eventsToSetOver = new ArrayList<Task>();
    	for (Task t: internalList) {
    	    if (t.isEvent() && isOverdue(t)) {
    	        eventsToSetOver.add(t);
    	    }
    	}
    	for (Task overEvents: eventsToSetOver) {
    	    try {
                mark(overEvents);
            } catch (TaskNotFoundException e) {
                assert false: "Task should not be missing";
            } catch (DuplicateMarkAsDoneException e) {
                assert false: "Task should not be marked done";
            }
    	}
    }
    
    private boolean isOverdue(Task t) {
        LocalDateTime currentTime = TimeUtil.createCurrentTime();
    	LocalDateTime taskTime = t.getPeriod().getEndDate().getDate().atTime(t.getPeriod().getEndTime().getTime());
    	return currentTime.isAfter(taskTime);
    }
    
```
###### /java/seedu/taskitty/model/task/UniqueTaskList.java
``` java
    public FilteredList<Task> getFilteredTaskList() {
        return internalList.filtered(null);
    }
```
###### /java/seedu/taskitty/model/TaskManager.java
``` java
    /**
     * Marks a task as done in the task manager.
     * 
     * @throws UniqueTaskList.TaskNotFoundException if task is not found.
     * @throws UniqueTaskList.DuplicateMarkAsDoneException if task has already been previously marked as done
     */
    public void markTaskAsDoneTask(ReadOnlyTask key) throws UniqueTaskList.DuplicateMarkAsDoneException, UniqueTaskList.TaskNotFoundException {
    	tasks.mark(key);
    }
    
```
###### /java/seedu/taskitty/ui/DeadlineCard.java
``` java
        TaskDate endTaskDate = task.getPeriod().getEndDate();
        endDate.setText("Due: " + DateUtil.createDateString(endTaskDate.getDate()));
        
        TaskTime taskEndTime = task.getPeriod().getEndTime();
        endTime.setText(" " + TimeUtil.createTimeString(taskEndTime.getTime()));
        
```
###### /java/seedu/taskitty/ui/DeadlineCard.java
``` java
        boolean isDone = task.getIsDone();
        if (isDone) {
            cardPane.setStyle("-fx-background-color: grey");
            name.setStyle("-fx-text-fill: white");
            id.setStyle("-fx-text-fill: white");
            endDate.setStyle("-fx-text-fill: white");
            endTime.setStyle("-fx-text-fill: white");
            
        } else {
            
        	// only deadline tasks have isOverdue attribute
            boolean isOverdue = task.isOverdue();
            if (isOverdue) {
                cardPane.setStyle("-fx-background-color: red");
            }
        }
        
```
###### /java/seedu/taskitty/ui/DeadlineListPanel.java
``` java
/**
 * Panel containing the list of deadline tasks.
 */
public class DeadlineListPanel extends TaskListPanel {
    private static final String FXML = "DeadlineListPanel.fxml";
    
    @FXML
    private Label header;
    
    @FXML
    private ListView<ReadOnlyTask> deadlineListView;
    
    public static final int DEADLINE_CARD_ID = 1;
    
    public DeadlineListPanel() {
        super();
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @Override
    public int getTaskCardID() {
        return DEADLINE_CARD_ID;
    }
    
    @Override
    public void configure(ObservableList<ReadOnlyTask> deadlineList) {
    	header.setText("DEADLINES [d]");
    	header.setStyle("-fx-text-fill: white");
        setConnections(deadlineListView, deadlineList);
        addToPlaceholder();
    }
    
}
```
###### /java/seedu/taskitty/ui/EventCard.java
``` java
        TaskDate startTaskDate = task.getPeriod().getStartDate();
        startDate.setText("Start: " + DateUtil.createDateString(startTaskDate.getDate()));
        
        TaskTime taskStartTime = task.getPeriod().getStartTime();
        startTime.setText(" "+TimeUtil.createTimeString(taskStartTime.getTime()));
        
        
        TaskDate endTaskDate = task.getPeriod().getEndDate();
        endDate.setText("End:  " + DateUtil.createDateString(endTaskDate.getDate()));

        TaskTime taskEndTime = task.getPeriod().getEndTime();
        endTime.setText(" "+TimeUtil.createTimeString(taskEndTime.getTime()));
        
```
###### /java/seedu/taskitty/ui/EventCard.java
``` java
        boolean isDone = task.getIsDone();
        if (isDone) {
            cardPane.setStyle("-fx-background-color: grey");
            name.setStyle("-fx-text-fill: white");
            id.setStyle("-fx-text-fill: white");
            startDate.setStyle("-fx-text-fill: white");
            endDate.setStyle("-fx-text-fill: white");
            startTime.setStyle("-fx-text-fill: white");
            endTime.setStyle("-fx-text-fill: white");
        }
        
```
###### /java/seedu/taskitty/ui/EventListPanel.java
``` java

/**
 * Panel containing the list of event tasks.
 */
public class EventListPanel extends TaskListPanel {
    private static final String FXML = "EventListPanel.fxml";
    
    @FXML
    private Label date;
    
    @FXML
    private Label header;
    
    @FXML
    private ListView<ReadOnlyTask> eventListView;
    
    public static final int EVENT_CARD_ID = 2;
    
    public EventListPanel() {
        super();
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @Override
    public int getTaskCardID() {
        return EVENT_CARD_ID;
    }
    
    @Override
    public void configure(ObservableList<ReadOnlyTask> eventList) {
    	header.setText("EVENTS [e]");
    	header.setStyle("-fx-text-fill: white");
    	setDefaultDate();
        setConnections(eventListView, eventList);
        addToPlaceholder();
    }
    
    /**
     * For when no view command is executed.
     */
    public void setEmptyDate() {
    	date.setText("");
    }
    
    /** 
     * For when `view today` is executed, and today's date with the "(today)" label will be shown.
     */
    public void setDefaultDate() {
    	
    	date.setText(DateUtil.createDefaultDateString());
    	date.setStyle("-fx-text-fill: black");
    	date.setStyle("-fx-background-color: white");
    }
    
    /**
     * For when `view date` is executed, and that date will be shown.
     * @param newDate
     */
    public void updateDate(LocalDate newDate) {
    	DateFormat df = new SimpleDateFormat("dd MMM yyyy");
    	date.setText(df.format(newDate));
    }
}
```
###### /java/seedu/taskitty/ui/MainWindow.java
``` java
    @FXML
    private AnchorPane taskListPanelPlaceholder;
    
    @FXML
    private AnchorPane deadlineListPanelPlaceholder;

    @FXML
    private AnchorPane eventListPanelPlaceholder;

```
###### /java/seedu/taskitty/ui/MainWindow.java
``` java
    public void fillInnerParts() {

        taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList(), new TodoListPanel());
        deadlineListPanel = TaskListPanel.load(primaryStage, getDeadlineListPlaceholder(), logic.getFilteredDeadlineList(), new DeadlineListPanel());
        eventListPanel = TaskListPanel.load(primaryStage, getEventListPlaceholder(), logic.getFilteredEventList(), new EventListPanel());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getTaskManagerFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }
    
```
###### /java/seedu/taskitty/ui/MainWindow.java
``` java
    private AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }
    
    private AnchorPane getDeadlineListPlaceholder() {
        return deadlineListPanelPlaceholder;
    }
    
    private AnchorPane getEventListPlaceholder() {
        return eventListPanelPlaceholder;
    }

```
###### /java/seedu/taskitty/ui/MainWindow.java
``` java
    /**
     *  Initialises the list to show today's events upon UI initialisation
     * */
    public void initialiseList() {
    	logic.initialiseList();
    }
    
```
###### /java/seedu/taskitty/ui/ResultDisplay.java
``` java
    private static final String WELCOME_MESSAGE = "Welcome! Here is your agenda for today:";
    private static final String WELCOME_MESSAGE_WITH_OVERDUE_DEADLINES = "Welcome! You have overdue tasks.";
    private static boolean hasOverdue;
    
```
###### /java/seedu/taskitty/ui/ResultDisplay.java
``` java
    public void configure() {
    	postCorrectWelcomeMessage();
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
    }
    
```
###### /java/seedu/taskitty/ui/ResultDisplay.java
``` java
    private void displayOverdueWelcomeMessage() {
    	postMessage(WELCOME_MESSAGE_WITH_OVERDUE_DEADLINES);
    }
    
    public static void setOverdue() {
    	hasOverdue = true;
    }
    
    private void postCorrectWelcomeMessage() {
    	if (!hasOverdue) {
        	postMessage(WELCOME_MESSAGE);
        } else {
        	displayOverdueWelcomeMessage();
        }
    }

}
```
###### /java/seedu/taskitty/ui/StatusBarFooter.java
``` java
    public static final String COMPLETED_TASKS = "completed tasks";
    public static final String ALL_TASKS = "all tasks";
    public static final String UPCOMING_TASKS = "upcoming tasks";
    private StatusBar viewStatus;
    
```
###### /java/seedu/taskitty/ui/StatusBarFooter.java
``` java
    public void configure(String saveLocation) {
        addMainPane();
        addSyncStatus();
        setSyncStatus("Not updated yet in this session");
        addSaveLocation();
        addViewStatus();
        setViewStatus("Viewing: "+ UPCOMING_TASKS);
        setSaveLocation("./" + saveLocation);
        registerAsAnEventHandler(this);
    }
```
###### /java/seedu/taskitty/ui/StatusBarFooter.java
``` java
    private void setViewStatus(String status) {
    	this.viewStatus.setText(status);
    }
   
    private void addViewStatus() {
    	this.viewStatus = new StatusBar();
    	FxViewUtil.applyAnchorBoundaryParameters(viewStatus, 0.0, 0.0, 0.0, 0.0);
        viewStatusBarPane.getChildren().add(viewStatus);
    }
    
```
###### /java/seedu/taskitty/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleViewTypeChangedEvent(ViewTypeChangedEvent vtce) {
    	String newView = vtce.viewType.toString();
    	String viewStatus = "Viewing: ";
    	switch(newView) {
    		case("date"):
    			viewStatus += DateUtil.createUISpecifiedDateString(vtce.getDate());
    			break;
    		case("done"):
    			viewStatus += COMPLETED_TASKS;
    			break;
    		case("all"):
    			viewStatus += ALL_TASKS;
    			break;
    		default:
    			viewStatus += UPCOMING_TASKS;
    	}
    	
    	logger.info(LogsCenter.getEventHandlingLogMessage(vtce, "Setting filtered view to " + newView));
    	setViewStatus(viewStatus); 
    	
    }
    
    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent tmce) {
        String lastUpdated = (new Date()).toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(tmce, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
}
```
###### /java/seedu/taskitty/ui/TodoCard.java
``` java
        boolean isDone = task.getIsDone();
        if (isDone) {
        	cardPane.setStyle("-fx-background-color: grey");
        	name.setStyle("-fx-text-fill: white");
        	id.setStyle("-fx-text-fill: white");
       
        }
        
```
###### /java/seedu/taskitty/ui/TodoListPanel.java
``` java

/**
 * Panel containing the list of todo tasks.
 */
public class TodoListPanel extends TaskListPanel {
    private static final String FXML = "TodoListPanel.fxml";

    @FXML
    private Label header;
    
    @FXML
    private ListView<ReadOnlyTask> todoListView;
    
    public static final int TODO_CARD_ID = 0;

    public TodoListPanel() {
        super();
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @Override
    public int getTaskCardID() {
        return TODO_CARD_ID;
    }
    
    @Override
    public void configure(ObservableList<ReadOnlyTask> taskList) {
    	header.setText("TODOS [t]");
    	header.setStyle("-fx-text-fill: white");
        setConnections(todoListView, taskList);
        addToPlaceholder();
    }

    // since we have no more select command this becomes useless... right?
//    public void scrollTo(int index) {
//        Platform.runLater(() -> {
//            todoListView.scrollTo(index);
//            todoListView.getSelectionModel().clearAndSelect(index);
//        });
//    }

}
```
###### /resources/view/EventListCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane gridLinesVisible="true" HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints halignment="CENTER" hgrow="ALWAYS" />
                <ColumnConstraints hgrow="ALWAYS" maxWidth="215.0" minWidth="215.0" prefWidth="215.0" />
            </columnConstraints>
            <children>
            <VBox alignment="CENTER_LEFT" prefHeight="102.0" prefWidth="94.0" GridPane.columnIndex="1" GridPane.hgrow="ALWAYS" GridPane.vgrow="ALWAYS">
               <padding>
                  <Insets bottom="5.0" left="15.0" right="5.0" top="5.0" />
               </padding>
               <stylesheets>
                  <URL value="@DarkTheme.css" />
                  <URL value="@Extensions.css" />
               </stylesheets>
               <GridPane.margin>
                  <Insets right="5.0" />
               </GridPane.margin>
               <children>
                  <HBox minWidth="150.0">
                     <children>
                        <Label fx:id="startDate" styleClass="cell_small_label" text="Start: \$startDate" />
                        <Label fx:id="startTime" styleClass="cell_small_label" text="\$startTime" HBox.hgrow="ALWAYS">
                           <HBox.margin>
                              <Insets />
                           </HBox.margin>
                        </Label>
                     </children>
                  </HBox>
                  <HBox alignment="CENTER_LEFT">
                     <children>
                        <Label fx:id="endDate" styleClass="cell_small_label" text="End: \$endDate" />
                        <Label fx:id="endTime" styleClass="cell_small_label" text="\$endTime">
                           <HBox.margin>
                              <Insets />
                           </HBox.margin></Label>
                     </children>
                  </HBox>
                          <Label fx:id="tags" styleClass="cell_small_label" text="\$tags" />
               </children>
            </VBox>
                <VBox alignment="CENTER_LEFT" GridPane.columnIndex="0" GridPane.hgrow="ALWAYS" GridPane.vgrow="ALWAYS">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5.0" left="15.0" right="5.0" top="5.0" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER_LEFT" spacing="5">
                     <children>
                                <HBox>
                           <children>
                                       <Label fx:id="id" styleClass="cell_big_label" />
                                       <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
                           </children>
                                </HBox>
                     </children>
                        </HBox>
                  <HBox alignment="CENTER_LEFT" spacing="5" />
                    </children>
               <GridPane.margin>
                  <Insets bottom="20.0" top="20.0" />
               </GridPane.margin>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
###### /resources/view/EventListPanel.fxml
``` fxml

<VBox minWidth="400.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.taskitty.ui.EventListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
      <Label fx:id="header" text="Label" VBox.vgrow="ALWAYS">
         <VBox.margin>
            <Insets bottom="4.0" left="4.0" right="4.0" />
         </VBox.margin>
      </Label>
      <AnchorPane style="-fx-background-color: white;">
         <children>
            <Label fx:id="date" text="Label" AnchorPane.bottomAnchor="4.0" AnchorPane.leftAnchor="4.0" AnchorPane.rightAnchor="4.0" AnchorPane.topAnchor="4.0" />
         </children>
         <VBox.margin>
            <Insets />
         </VBox.margin>
      </AnchorPane>
        <ListView fx:id="eventListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### /resources/view/MainWindow.fxml
``` fxml

<VBox minWidth="500.0" prefWidth="500.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.taskitty.ui.MainWindow">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar VBox.vgrow="ALWAYS">
         <menus>
```
###### /resources/view/MainWindow.fxml
``` fxml
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane" VBox.vgrow="ALWAYS">
         <padding>
            <Insets left="10.0" right="10.0" />
         </padding>
         <children>
            <ImageView fitHeight="50.0" fitWidth="50.0" pickOnBounds="true" preserveRatio="true" x="5.0" AnchorPane.leftAnchor="2.0">
               <image>
                  <Image url="@../images/specsCat.png" />
               </image>
            </ImageView>
         </children>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane" VBox.vgrow="NEVER">
           <padding>
               <Insets left="10.0" right="10.0" />
           </padding>
       </AnchorPane>
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.25" styleClass="anchor-pane-with-border" VBox.vgrow="ALWAYS">
         <items>
            <SplitPane id="splitPane" fx:id="splitPane1" dividerPositions="0.5" orientation="VERTICAL" VBox.vgrow="ALWAYS">
              <items>
                  <VBox VBox.vgrow="ALWAYS">
                     <children>
                      <AnchorPane fx:id="deadlineListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                     </children>
                     <padding>
                        <Insets bottom="10.0" left="10.0" right="10.0" top="2.0" />
                     </padding>
                  </VBox>
                  <VBox fx:id="taskList" VBox.vgrow="ALWAYS">
                     <children>
                      <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                     </children>
                     <padding>
                        <Insets bottom="10.0" left="10.0" right="10.0" top="2.0" />
                     </padding>
                  </VBox>
              </items>
            </SplitPane>
            <VBox>
               <children>
                  <AnchorPane fx:id="eventListPanelPlaceholder" VBox.vgrow="ALWAYS">
                      <padding>
                          <Insets bottom="10.0" left="10.0" right="10.0" top="2.0" />
                      </padding>
                  </AnchorPane>
               </children>
            </VBox>
         </items>
      </SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="ALWAYS" />
   </children>
</VBox>
```
###### /resources/view/StatusBarFooter.fxml
``` fxml

<GridPane styleClass="grid-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.taskitty.ui.StatusBarFooter">
<columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
  <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
  <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
</columnConstraints>
 <children>
      <AnchorPane id="viewStatusBarPane" fx:id="viewStatusBarPane" />
      <AnchorPane id="syncStatusBarPane" fx:id="syncStatusBarPane" minWidth="0.0" styleClass="anchor-pane" GridPane.columnIndex="1" />
      <AnchorPane id="saveLocStatusBarPane" fx:id="saveLocStatusBarPane" minWidth="0.0" styleClass="anchor-pane" GridPane.columnIndex="2" />
 </children>
   <rowConstraints>
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### /resources/view/TodoListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" prefHeight="75.0" prefWidth="442.0" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="440.0" minWidth="10.0" prefWidth="440.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="100.0" minWidth="0.0" prefWidth="0.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" maxWidth="1.7976931348623157E308" GridPane.columnIndex="0" GridPane.hgrow="ALWAYS" GridPane.vgrow="ALWAYS">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox alignment="CENTER_LEFT" spacing="5" VBox.vgrow="ALWAYS">
                            <children>
                                <HBox>
                                    <Label fx:id="id" styleClass="cell_big_label" />
                                    <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
                                </HBox>
                            </children>
                        </HBox>
                          <Label fx:id="tags" styleClass="cell_small_label" text="\$tags" VBox.vgrow="ALWAYS">
                     <VBox.margin>
                        <Insets top="5.0" />
                     </VBox.margin></Label>
                    </children>
               <GridPane.margin>
                  <Insets bottom="10.0" top="10.0" />
               </GridPane.margin>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
