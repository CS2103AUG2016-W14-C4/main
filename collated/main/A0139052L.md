# A0139052L
###### /java/seedu/taskitty/commons/util/TaskUtil.java
``` java
/**
 * Helper functions for handling tasks related items.
 *
 */
public class TaskUtil {
    
    /**
     * Returns the specified index in the {@code command} IF a valid category character was given.
     *   else return the default index
     */
    public static int getCategoryIndex(char category) {
        
        category = Character.toLowerCase(category);
        switch(category) {
        
            case(Task.TODO_CATEGORY_CHAR) :
                return Task.TODO_CATEGORY_INDEX;
            
            case(Task.DEADLINE_CATEGORY_CHAR): 
                return Task.DEADLINE_CATEGORY_INDEX;
            
            case(Task.EVENT_CATEGORY_CHAR): 
                return Task.EVENT_CATEGORY_INDEX;
            
            default: 
                return getDefaultCategoryIndex();
            
        }
    }
    
    /**
     * Returns the default category index for when the user does not give any
     */
    public static int getDefaultCategoryIndex() {
        return Task.DEFAULT_CATEGORY_INDEX;
    }
    
}
```
###### /java/seedu/taskitty/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task manager.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_PARAMETER = COMMAND_WORD + " [index] [more indexes]...";
    public static final String MESSAGE_USAGE = "This command deletes tasks from TasKitty, Meow!"
            + "\n[index] is the index eg. t1, d1, e1.";

    public static final String MESSAGE_DELETE_TASK_SUCCESS_HEADER = " %1$s Tasks Deleted: ";
    
    private boolean hasInvalidIndex;
    
    private boolean hasDuplicateIndexesProvided;
    
    private final List<Pair<Integer, Integer>> listOfIndexes;
    
    private final String commandText;
    
    public DeleteCommand(List<Pair<Integer, Integer>> listOfIndexes, String commandText) {
        assert listOfIndexes != null;
        this.listOfIndexes = listOfIndexes;
        this.hasInvalidIndex = false;
        this.hasDuplicateIndexesProvided = false;
        this.commandText = commandText;
    }

    @Override
    public CommandResult execute() {
        
        int categoryIndex;
        int targetIndex;
        ArrayList<ReadOnlyTask> listOfTaskToDelete = new ArrayList<ReadOnlyTask>();
        StringBuilder invalidIndexMessageBuilder = new StringBuilder(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX + ": ");
        StringBuilder resultMessageBuilder = new StringBuilder(String.format(MESSAGE_DELETE_TASK_SUCCESS_HEADER, listOfIndexes.size()));
        StringBuilder duplicateIndexesProvidedMessageBuilder = new StringBuilder(Messages.MESSAGE_DUPLICATE_INDEXES_PROVIDED + ": ");
        
        for (Pair<Integer, Integer> indexPair: listOfIndexes) {
            categoryIndex = indexPair.getKey();
            targetIndex = indexPair.getValue();
            assert categoryIndex >= 0 && categoryIndex < 3;
            
            String currentTaskIndex = Task.CATEGORIES[categoryIndex] + targetIndex + " ";
            
            UnmodifiableObservableList<ReadOnlyTask> lastShownList = AppUtil.getCorrectListBasedOnCategoryIndex(model, categoryIndex); 
            
            if (lastShownList.size() < targetIndex) {
                hasInvalidIndex = true;
                invalidIndexMessageBuilder.append(currentTaskIndex);
                continue;
            }
            
            ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
            
            if (!listOfTaskToDelete.contains(taskToDelete)) {
                listOfTaskToDelete.add(taskToDelete);
                resultMessageBuilder.append(taskToDelete.getName() + ", ");
            } else {
                hasDuplicateIndexesProvided = true;
                duplicateIndexesProvidedMessageBuilder.append(currentTaskIndex);
            }                       
        }
        
        if (hasInvalidIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            String invalidIndexMessage = invalidIndexMessageBuilder.toString().trim();
            return new CommandResult(invalidIndexMessage);
        }
        
        if (hasDuplicateIndexesProvided) {
            indicateAttemptToExecuteIncorrectCommand();
            String duplicateIndexesProvidedMessage = duplicateIndexesProvidedMessageBuilder.toString().trim();
            return new CommandResult(duplicateIndexesProvidedMessage);
        } 
        
        try {
             model.deleteTasks(listOfTaskToDelete);
             model.storeCommandInfo(COMMAND_WORD, commandText, listOfTaskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        
        resultMessageBuilder.delete(resultMessageBuilder.length() - 2, resultMessageBuilder.length());// remove the extra separator at the end
        String resultMessage = resultMessageBuilder.toString();
        return new CommandResult(resultMessage);
    }

}
```
###### /java/seedu/taskitty/logic/commands/RedoCommand.java
``` java
/**
* Redoes previous command given
*/
public class RedoCommand extends Command {
    
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_PARAMETER = COMMAND_WORD;
    public static final String MESSAGE_USAGE = "This command redos your previous undo action, Meow!";

    public static final String MESSAGE_REDO_SUCCESS = "Undoed action restored: ";
    public static final String MESSAGE_NO_RECENT_UNDO_COMMANDS = "There is no recent undoed command in this session.";
    
    @Override
    public CommandResult execute() {
        try {
            String commandRedone = model.redo();
            return new CommandResult(MESSAGE_REDO_SUCCESS + commandRedone);
        } catch (NoRecentUndoCommandException e) {
            return new CommandResult(MESSAGE_NO_RECENT_UNDO_COMMANDS);
        }
    }

}
```
###### /java/seedu/taskitty/logic/commands/UndoCommand.java
``` java
/**
 * Undoes previous command given
 */
public class UndoCommand extends Command {
    
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_PARAMETER = COMMAND_WORD;
    public static final String MESSAGE_USAGE = "This command undos your previous action, Meow!";

    public static final String MESSAGE_UNDO_SUCCESS = "Previous action undone: ";
    public static final String MESSAGE_NO_PREVIOUS_VALID_COMMANDS = "There is no more previous command in this session.";
    
    @Override
    public CommandResult execute() {
        try {
            String commandUndone = model.undo();
            return new CommandResult(MESSAGE_UNDO_SUCCESS + commandUndone);
        } catch (NoPreviousValidCommandException e) {
            return new CommandResult(MESSAGE_NO_PREVIOUS_VALID_COMMANDS);
        }       
    }

}
```
###### /java/seedu/taskitty/logic/parser/CommandParser.java
``` java
    /**
     * Converts any number formats of date from the local format to one which can be parsed by natty
     * @param arguments
     * @return arguments with converted dates if any
     */
    private String convertToNattyDateFormat(String arguments) {
        Matcher matchDate = LOCAL_DATE_FORMAT.matcher(arguments);
        if (matchDate.matches()) {
            String localDateString = matchDate.group("arguments");
            String dateSeparator = getDateSeparator(localDateString);
            return convertToNattyFormat(arguments, localDateString, dateSeparator);
        } else {
            return arguments;
        }       
    }
    
    /**
     * Get the separator between day month and year in a date
     * @param localDateString the string representing the date
     * @return the separator character used in localDateString
     */
    private String getDateSeparator(String localDateString) {
        // if 2nd char in string is an integer, then the 3rd char must be the separator
        // else 2nd char is the separator
        if (StringUtil.isInteger(localDateString.substring(1,2))) {
            return localDateString.substring(2, 3);
        } else {
            return localDateString.substring(1, 2);
        }
    }
    
    /**
     * Convert the local date format inside arguments into a format
     * which can be parsed by natty
     * @param arguments the full argument string
     * @param localDateString the localDate extracted out from arguments
     * @param dateSeparator the separator for the date extracted out
     * @return converted string where the date format has been converted from local to natty format
     */
    private String convertToNattyFormat(String arguments, String localDateString, String dateSeparator) {
        String[] dateComponents = localDateString.split(dateSeparator);
        int indexOfDate = arguments.indexOf(localDateString);
        String nattyDateString = swapDayAndMonth(dateComponents, dateSeparator);
        arguments = arguments.replace(localDateString, nattyDateString);
        String stringFromConvertedDate = arguments.substring(indexOfDate);
        String stringUpToConvertedDate = arguments.substring(0, indexOfDate);
        return convertToNattyDateFormat(stringUpToConvertedDate) + stringFromConvertedDate;
    }
    
    /**
     * Swaps the day and month component of the date
     * @param dateComponents the String array obtained after separting the date string
     * @param dateSeparator the Separator used in the date string
     * @return the date string with its day and month component swapped
     */
    private String swapDayAndMonth(String[] dateComponents, String dateSeparator) {
        StringBuilder nattyDateStringBuilder = new StringBuilder();
        nattyDateStringBuilder.append(dateComponents[1]);
        nattyDateStringBuilder.append(dateSeparator);
        nattyDateStringBuilder.append(dateComponents[0]);
        return nattyDateStringBuilder.toString();
    }
    
```
###### /java/seedu/taskitty/logic/parser/CommandParser.java
``` java
    /**
     * Parses arguments in the context of the delete person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {        
        String dataArgs = args.trim();
        String[] indexes = dataArgs.split("\\s");                
        ArrayList<Pair<Integer, Integer>> listOfIndexes = getIndexes(indexes);
        
        if (listOfIndexes == null) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            Command.MESSAGE_FORMAT + DeleteCommand.MESSAGE_PARAMETER));
        }
        
        return new DeleteCommand(listOfIndexes, args);
    }   
    
```
###### /java/seedu/taskitty/logic/parser/CommandParser.java
``` java
    /**
     * 
     * Parses each index string in the array and adds them to a list if valid
     * @param indexes the string array of indexes separated
     * @return a list of all valid indexes parsed or null if an invalid index was given
     */
    private ArrayList<Pair<Integer, Integer>> getIndexes(String[] indexes) {        
        Pair<Integer, Integer> categoryAndIndex;
        ArrayList<Pair<Integer, Integer>> listOfIndexes = new ArrayList<Pair<Integer, Integer>>();       
        for (String index: indexes) {
            if (index.contains("-")) {               
                String[] splitIndex = index.split("-");
                categoryAndIndex = getCategoryAndIndex(splitIndex[0]);
                Optional<Integer> secondIndex = parseIndex(splitIndex[1]);                               
                
                if (!secondIndex.isPresent() || categoryAndIndex == null) {
                    return null;
                }                
                int firstIndex = categoryAndIndex.getValue();               
                int categoryIndex = categoryAndIndex.getKey();
                
                if (firstIndex >= secondIndex.get()) {
                    return null;
                }                
                for (; firstIndex <= secondIndex.get(); firstIndex++) {
                    categoryAndIndex = new Pair<Integer, Integer>(categoryIndex, firstIndex);
                    listOfIndexes.add(categoryAndIndex);
                }                
            } else {
                categoryAndIndex = getCategoryAndIndex(index);               
                if (categoryAndIndex == null) {
                    return null;
                }               
                listOfIndexes.add(categoryAndIndex);
            }
        }
        return listOfIndexes;
    }
    
```
###### /java/seedu/taskitty/logic/parser/CommandParser.java
``` java
    /**
     * Parses the string and returns the categoryIndex and the index if a valid one was given
     * @param args 
     * @return an int array with categoryIndex and index in 0 and 1 index respectively
     */
    private Pair<Integer, Integer> getCategoryAndIndex(String args) {
        
        if (args.trim().equals(EMPTY_STRING)) {
            return null;
        }
        
        // category index should be the first char in the string
        Optional<Integer> checkForCategory = parseIndex(args.substring(0, 1));
        Optional<Integer> index;
        int categoryIndex;
        
        if (checkForCategory.isPresent()){
            index = parseIndex(args);
            // give the default category index if none was provided
            categoryIndex = TaskUtil.getDefaultCategoryIndex();
        } else {
            // index should be the rest of the string if category char is present
            index = parseIndex(args.substring(1));
            categoryIndex = TaskUtil.getCategoryIndex(args.charAt(0));
        }
        
        if (!index.isPresent()){
            return null;
        }
        
        return new Pair<Integer, Integer>(categoryIndex, index.get());
    }
    
```
###### /java/seedu/taskitty/model/CommandHistoryManager.java
``` java
 * Class to store information of commands executed by user that is required for undo/redo function
 *
 */
public class CommandHistoryManager {
    
    private final Stack<String> historyCommandWords;
    private final Stack<String> historyCommandTexts;
    private final Stack<ReadOnlyTask> historyTasks;
    private final Stack<List<ReadOnlyTask>> historyListOfTasks;
    private final Stack<ReadOnlyTaskManager> historyTaskManagers;
    
    public CommandHistoryManager() {
        historyCommandWords = new Stack<String>();
        historyCommandTexts = new Stack<String>();
        historyTasks = new Stack<ReadOnlyTask>();
        historyListOfTasks = new Stack<List<ReadOnlyTask>>();
        historyTaskManagers = new Stack<ReadOnlyTaskManager>();
    }
    
    public boolean hasPreviousValidCommand() {
        return !historyCommandWords.isEmpty();
    }
    
    public String getCommandWord() {
        assert !historyCommandWords.isEmpty();
        return historyCommandWords.pop();
    }
    
    public String getCommandText() {
        assert !historyCommandTexts.isEmpty();
        return historyCommandTexts.pop();
    }
    
    public ReadOnlyTask getTask() {
        assert !historyTasks.isEmpty();
        return historyTasks.pop();
    }       
    
    public List<ReadOnlyTask> getListOfTasks() {
        assert !historyListOfTasks.isEmpty();
        return historyListOfTasks.pop();
    }
    
    public ReadOnlyTaskManager getTaskManager() {
        assert !historyTaskManagers.isEmpty();
        return historyTaskManagers.pop();
    }
    
    public void storeCommandWord(String command) {
        historyCommandWords.push(command);
    }
    
    public void storeCommandText(String commandText) {
        historyCommandTexts.push(commandText);
    }
    
    public void storeTask(ReadOnlyTask task) {
        historyTasks.push(task);
    }
    
    public void storeListOfTasks(List<ReadOnlyTask> listOfTasks) {
        historyListOfTasks.push(listOfTasks);
    }
    
    public void storeTaskManager(ReadOnlyTaskManager taskManager) {
        historyTaskManagers.push(taskManager);
    }
    
    public void clear() {
        historyCommandWords.clear();
        historyCommandTexts.clear();
        historyTasks.clear();
        historyListOfTasks.clear();
        historyTaskManagers .clear();
    }
    
}
```
###### /java/seedu/taskitty/model/Model.java
``` java
    /** Undoes the previous command if there is any 
     * @throws NoPreviousValidCommandException */
    String undo() throws NoPreviousValidCommandException;
    
    /** Redoes the previous undo command if there is any 
     * @throws NoRecentUndoCommandException */
    String redo() throws NoRecentUndoCommandException;
    
    /**
     * stores the info from an add/edit command that is needed for undoing/redoing functions
     */
    public void storeCommandInfo(String commandWord, String commandText, ReadOnlyTask... tasks);
    
    /**
     * stores the info from a delete/done command that is needed for undoing/redoing functions
     */
    public void storeCommandInfo(String commandWord, String commandText, List<ReadOnlyTask> deletedTasks);
    
    /**
     * stores the info from a clear command that is needed for undoing/redoing functions
     */
    public void storeCommandInfo(String commandWord);

    
```
###### /java/seedu/taskitty/model/ModelManager.java
``` java
    @Override
    public synchronized void deleteTasks(List<ReadOnlyTask> taskList) throws TaskNotFoundException {
        for (ReadOnlyTask targetTask: taskList) {
            taskManager.removeTask(targetTask);
        }
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {        
        taskManager.addTask(task);
        indicateTaskManagerChanged();
    }    
   
```
###### /java/seedu/taskitty/model/ModelManager.java
``` java
   	@Override
    public synchronized void storeCommandInfo(String commandWord, String commandText, ReadOnlyTask... tasks) {
   	    undoHistory.storeCommandWord(commandWord);
   	    undoHistory.storeCommandText(commandWord + commandText);
   	    for (ReadOnlyTask task: tasks) {
   	        undoHistory.storeTask(task);
   	    }   	    
   	    redoHistory.clear();
   	}
   	
   	@Override
    public synchronized void storeCommandInfo(String commandWord, String commandText, List<ReadOnlyTask> markedTasks) {
        undoHistory.storeCommandWord(commandWord);
        undoHistory.storeListOfTasks(markedTasks);
        undoHistory.storeCommandText(commandWord + commandText);
        redoHistory.clear();
    }
   	
   	@Override
    public synchronized void storeCommandInfo(String commandWord) {
        undoHistory.storeCommandWord(commandWord);
        undoHistory.storeCommandText(commandWord);
        undoHistory.storeTaskManager(new TaskManager(taskManager));        
        redoHistory.clear();
    }
   	
   	@Override     
    public synchronized String undo() throws NoPreviousValidCommandException {
        if (!undoHistory.hasPreviousValidCommand()) {
            throw new NoPreviousValidCommandException(null);
        }
        return revertBackPreviousState(undoHistory, redoHistory, false);        
    }        
    
   	@Override     
    public synchronized String redo() throws NoRecentUndoCommandException {
        if (!redoHistory.hasPreviousValidCommand()) {
            throw new NoRecentUndoCommandException(null);
        }
        return revertBackPreviousState(redoHistory, undoHistory, true);        
    }
   	
```
###### /java/seedu/taskitty/model/ModelManager.java
``` java
	/**
	 * Reverts back to the previous state by undoing/redoing the previous action
	 * @param toGetInfo the storage in which to get the info from
	 * @param toStoreInfo the storage in which to store the info into
	 * @param isRedo check if it is undo/redo calling this method
	 * @return the commandText string for result message in Undo/Redo Command
	 */
	private String revertBackPreviousState(CommandHistoryManager toGetInfo, CommandHistoryManager toStoreInfo, boolean isRedo) {
        String commandWord = toGetInfo.getCommandWord();
        toStoreInfo.storeCommandWord(commandWord);
        
        try {
            switch(commandWord) {
            
            case AddCommand.COMMAND_WORD:
                revertAddCommand(toGetInfo, toStoreInfo, isRedo);
                break;
                
            case DeleteCommand.COMMAND_WORD:
                revertDeleteCommand(toGetInfo, toStoreInfo, isRedo);
                break;
                
            case EditCommand.COMMAND_WORD:
                revertEditCommand(toGetInfo, toStoreInfo, isRedo);
                break;
                
            case ClearCommand.COMMAND_WORD:
                revertClearCommand(toGetInfo, toStoreInfo, isRedo);
                break;
                
            case DoneCommand.COMMAND_WORD:
                revertDoneCommand(toGetInfo, toStoreInfo, isRedo);
                break;
                
            default:
                assert false: "Should not have an invalid Command Word";
                break;
            }            
        } catch (Exception e) {
            assert false: "Should not be unable to undo/redo previous command action";
        }
        String commandText = toGetInfo.getCommandText();
        toStoreInfo.storeCommandText(commandText);
        indicateTaskManagerChanged();
        return commandText;
    }
	
	/**
     * Reverts an AddCommand depending on whether is redo/undo calling it
     */
    private void revertAddCommand(CommandHistoryManager toGetInfo, CommandHistoryManager toStoreInfo, boolean isRedo)
            throws DuplicateTaskException, TaskNotFoundException {
        ReadOnlyTask taskAdded = toGetInfo.getTask();
        if (isRedo) {
            taskManager.addTask((Task) taskAdded);
        } else {
            taskManager.removeTask(taskAdded); 
        } 
        toStoreInfo.storeTask(taskAdded);
    }
    
	/**
     * Reverts a DeleteCommand depending on whether is redo/undo calling it
     */
    private void revertDeleteCommand(CommandHistoryManager toGetInfo, CommandHistoryManager toStoreInfo, boolean isRedo)
            throws TaskNotFoundException, DuplicateTaskException {
        List<ReadOnlyTask> listOfDeletedTasks = toGetInfo.getListOfTasks();
        toStoreInfo.storeListOfTasks(listOfDeletedTasks);
        if (isRedo) {
            for (ReadOnlyTask taskDeleted: listOfDeletedTasks) {
                taskManager.removeTask(taskDeleted);
            }
       } else {
           for (ReadOnlyTask taskDeleted: listOfDeletedTasks) {
               taskManager.addTask((Task) taskDeleted);
           }
       }
    }
	
	/**
     * Reverts an EditCommand depending on whether is redo/undo calling it
     */
    private void revertEditCommand(CommandHistoryManager toGetInfo, CommandHistoryManager toStoreInfo, boolean isRedo)
            throws DuplicateTaskException, TaskNotFoundException {
        ReadOnlyTask taskBeforeEdit = toGetInfo.getTask();
        ReadOnlyTask taskAfterEdit = toGetInfo.getTask();
        if (isRedo) {
            taskManager.addTask((Task) taskAfterEdit);
            taskManager.removeTask(taskBeforeEdit);                    
        } else {
            taskManager.addTask((Task) taskBeforeEdit);
            taskManager.removeTask(taskAfterEdit);
        }
        toStoreInfo.storeTask(taskAfterEdit);
        toStoreInfo.storeTask(taskBeforeEdit);
    }
    
	/**
     * Reverts a ClearCommand depending on whether is redo/undo calling it
     */
    private void revertClearCommand(CommandHistoryManager toGetInfo, CommandHistoryManager toStoreInfo,
            boolean isRedo) {
        ReadOnlyTaskManager previousTaskManager = toGetInfo.getTaskManager();
        if (isRedo) {
            resetData(TaskManager.getEmptyTaskManager());
        } else {
            resetData(previousTaskManager);
        }
        toStoreInfo.storeTaskManager(previousTaskManager);
    }
    
	/**
     * Reverts a DoneCommand depending on whether is redo/undo calling it
     */
    private void revertDoneCommand(CommandHistoryManager toGetInfo, CommandHistoryManager toStoreInfo, boolean isRedo)
            throws DuplicateMarkAsDoneException, TaskNotFoundException {
        List<ReadOnlyTask> listOfTasksMarked = toGetInfo.getListOfTasks();
        toStoreInfo.storeListOfTasks(listOfTasksMarked);
        if (isRedo) {
            for (ReadOnlyTask taskToRevertMark: listOfTasksMarked) {
                taskManager.markTaskAsDoneTask(taskToRevertMark);
            }
        } else {
            for (ReadOnlyTask taskToRevertMark: listOfTasksMarked) {
                taskManager.unMarkTaskAsDoneTask(taskToRevertMark);
            }    
        }
    }
}

```
###### /java/seedu/taskitty/model/task/Task.java
``` java
    @Override
    public int compareTo(Task taskToCompare) {
        // sort all tasks that are done to the back of the list
	    if (this.getIsDone() && !taskToCompare.getIsDone()) {
	        return 1;
	    } else if (!this.getIsDone() && taskToCompare.getIsDone()) {
	        return -1;
       } else {           
       	   int periodCompare = this.getPeriod().compareTo(taskToCompare.period);
       	   if (this.getIsDone()) {
       	       periodCompare = -periodCompare; // sort done tasks in the opposite order
       	   }
           //If no difference in date and time is found in period, compare using name
           if (periodCompare == 0) {
               return this.getName().fullName.toLowerCase().compareTo(taskToCompare.getName().fullName.toLowerCase());
           } else {
               return periodCompare;
           }
       }       
    }
	
}
```
###### /java/seedu/taskitty/model/task/TaskPeriod.java
``` java
    @Override
    public int compareTo(TaskPeriod periodToCompare) {
        // if task has are of the same format, sort by their date and times (if any)
        if (this.getNumArgs() == periodToCompare.getNumArgs()) {           
            return compareByDateAndTime(periodToCompare); 
        } else {
            return this.getNumArgs() - periodToCompare.getNumArgs();
        } 
    }

    private int compareByDateAndTime(TaskPeriod periodToCompare) {
        // sort events according to their start date or time
        if (this.isEvent()) {
            if (!this.getStartDate().equals(periodToCompare.getStartDate())) {
                return this.getStartDate().getDate().compareTo(periodToCompare.getStartDate().getDate());
            } else if (!this.getStartTime().equals(periodToCompare.getStartTime())) {
                return this.getStartTime().getTime().compareTo(periodToCompare.getStartTime().getTime());                    
            }
        }
        // if event has same start date and start time, sort it by its end date or end time like deadline
        if (this.isEvent() || this.isDeadline()) {
            if (!this.getEndDate().equals(periodToCompare.getEndDate())) {
                return this.getEndDate().getDate().compareTo(periodToCompare.getEndDate().getDate());
            } else if (!this.getEndTime().equals(periodToCompare.getEndTime())) {
                return this.getEndTime().getTime().compareTo(periodToCompare.getEndTime().getTime());                    
            } 
        }
        return 0; //no difference found
    }
    
}
```
###### /java/seedu/taskitty/model/task/UniqueTaskList.java
``` java
    /**
     * Adds a task into the list in a sorted fashion.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void addSorted(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        
        for (int i = 0; i < internalList.size(); i++) {
            if (toAdd.compareTo(internalList.get(i)) < 0) {
                internalList.add(i, toAdd);
                return;
            }
        }
        internalList.add(toAdd);
    }
    
    /**
     * Adds tasks to the list in an unsorted fashion. Used in initialization of TaskManager
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(toAdd);
    }
    
    /** 
     * Unmarks the given task as done from the list. Used only in redo function 
     */
    public void unmark(ReadOnlyTask toUnmark) {
        assert toUnmark != null && toUnmark.getIsDone();
        final boolean taskFoundAndUnmarkedAsDone = internalList.remove(toUnmark);
        assert taskFoundAndUnmarkedAsDone;
        
        Task editableToUnmark = (Task) toUnmark;
        editableToUnmark.unmarkAsDone();
        
        try {
            addSorted(editableToUnmark);
        } catch (DuplicateTaskException e) {
            assert false: "Should not have duplicate task";
        }
    }
    
```
###### /java/seedu/taskitty/ui/MainWindow.java
``` java
    private void setAccelerators() {
        helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
        exitMenuItem.setAccelerator(KeyCombination.valueOf("Esc"));
        undoMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl + Shift + U"));
        redoMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl + Shift + Y"));
        viewMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl + Shift + T"));
        viewAllMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl + Shift + L"));
        viewDoneMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl + Shift + D"));
        clearMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl + Shift + C"));        
    }
    
```
###### /java/seedu/taskitty/ui/MainWindow.java
``` java
    @FXML
    public void handleUndo() {
        commandBox.handleCommands("undo");
    }
    
    @FXML
    public void handleRedo() {
        commandBox.handleCommands("redo");
    }
    
    @FXML
    public void handleView() {
        commandBox.handleCommands("view");
    }
    
    @FXML
    public void handleViewAll() {
        commandBox.handleCommands("view all");
    }
            
    @FXML
    public void handleViewDone() {
        commandBox.handleCommands("view done");
    }
    
    @FXML
    public void handleClear() {
        commandBox.handleCommands("clear");
    }   
    
```
###### /resources/view/MainWindow.fxml
``` fxml
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem fx:id="exitMenuItem" mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Edit">
              <items>
                <MenuItem fx:id="undoMenuItem" mnemonicParsing="false" onAction="#handleUndo" text="Undo" />
                  <MenuItem fx:id="redoMenuItem" mnemonicParsing="false" onAction="#handleRedo" text="Redo" />
                  <MenuItem fx:id="clearMenuItem" mnemonicParsing="false" onAction="#handleClear" text="Clear" />
              </items>
            </Menu>
            <Menu mnemonicParsing="false" text="View">
              <items>
                  <MenuItem fx:id="viewMenuItem" mnemonicParsing="false" onAction="#handleView" text="Today" />
                  <MenuItem fx:id="viewDoneMenuItem" mnemonicParsing="false" onAction="#handleViewDone" text="Done" />
                <MenuItem fx:id="viewAllMenuItem" mnemonicParsing="false" onAction="#handleViewAll" text="All" />
              </items>
            </Menu>
```
