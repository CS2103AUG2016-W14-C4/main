# A0139930B
###### \java\seedu\taskitty\commons\events\ui\ShowToolTipEvent.java
``` java
/**
 * An event requesting to view the help page.
 */
public class ShowToolTipEvent extends BaseEvent {
    private ToolTip tooltip;
    
    public ShowToolTipEvent(String userInput) {
        tooltip = ToolTip.getInstance();
        tooltip.createToolTip(userInput);
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public String getToolTipMessage() {
        return tooltip.getMessage();
    }
    
    public String getToolTipDescription() {
        return tooltip.getDescription();
    }
    
    public boolean isUserInputValid() {
        return tooltip.isUserInputValid();
    }

}
```
###### \java\seedu\taskitty\logic\commands\AddCommand.java
``` java
    public static final String MESSAGE_PARAMETER = COMMAND_WORD
            + " <name> [start datetime] to [end datetime] [#tag]...";
    public static final String MESSAGE_USAGE = "This command adds a task to TasKitty, Meow!";

    public static final String MESSAGE_SUCCESS = "New task added:\n%1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private final Task toAdd;
    private final String commandText;

    /**
     * Convenience constructor using values parsed from Natty
     *
     * @throws IllegalValueException if data is invalid
     */
    public AddCommand(String[] data, Set<String> tags, String commandText) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        this.commandText = commandText;
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = createNewTaskFromData(data, tagSet);
    }
    
    /**
     * Returns a newly created Task based on the input data.
     * 
     * @throws IllegalValueException if any of the values are invalid or there are too many inputs
     */
    private Task createNewTaskFromData(String[] data, Set<Tag> tagSet) throws IllegalValueException {
        Task newTask;
        
        if (data.length == Task.TASK_COMPONENT_COUNT) {
            newTask = createNewTodoTask(data, tagSet);
        } else if (data.length == Task.DEADLINE_COMPONENT_COUNT) {
            newTask = createNewDeadlineTask(data, tagSet);
        } else if (data.length == Task.EVENT_COMPONENT_COUNT) {
            newTask = createNewEventTask(data, tagSet);
        } else {
            throw new IllegalValueException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    MESSAGE_FORMAT + MESSAGE_PARAMETER));
        }
        
        return newTask;
    }
    
    /**
     * Returns a newly created Todo Task
     * Todo Tasks only have name, tags
     * 
     * @throws IllegalValueException if any of the values are invalid
     */
    private Task createNewTodoTask(String[] data, Set<Tag> tagSet) throws IllegalValueException {
        assert data.length == Task.TASK_COMPONENT_COUNT;
        
        return new Task(new Name(data[Task.TASK_COMPONENT_INDEX_NAME]),
            new TaskPeriod(),
            new UniqueTagList(tagSet));
    }
    
    /**
     * Returns a newly created Deadline Task
     * Deadline Tasks only have name, endDate, endTime, tags
     * 
     * @throws IllegalValueException if any of the values are invalid
     */
    private Task createNewDeadlineTask(String[] data, Set<Tag> tagSet) throws IllegalValueException {
        assert data.length == Task.DEADLINE_COMPONENT_COUNT;
        
        return new Task(new Name(data[Task.DEADLINE_COMPONENT_INDEX_NAME]),
            new TaskPeriod(new TaskDate(data[Task.DEADLINE_COMPONENT_INDEX_END_DATE]),
                new TaskTime(data[Task.DEADLINE_COMPONENT_INDEX_END_TIME])),
            new UniqueTagList(tagSet));
    }
    
    /**
     * Returns a newly created Event Task
     * Event Tasks have name, startDate, startTime, endDate, endTime, tags
     * 
     * @throws IllegalValueException if any of the values are invalid
     */
    private Task createNewEventTask(String[] data, Set<Tag> tagSet) throws IllegalValueException {
        assert data.length == Task.EVENT_COMPONENT_COUNT;
        
        return new Task(new Name(data[Task.EVENT_COMPONENT_INDEX_NAME]),
            new TaskPeriod(new TaskDate(data[Task.EVENT_COMPONENT_INDEX_START_DATE]),
                new TaskTime(data[Task.EVENT_COMPONENT_INDEX_START_TIME]),
                new TaskDate(data[Task.EVENT_COMPONENT_INDEX_END_DATE]),
                new TaskTime(data[Task.EVENT_COMPONENT_INDEX_END_TIME])),
            new UniqueTagList(tagSet));
    }

```
###### \java\seedu\taskitty\logic\Logic.java
``` java
    /** Returns the filtered list of todo tasks */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Returns the filtered list of deadline tasks */
    ObservableList<ReadOnlyTask> getFilteredDeadlineList();

    /** Returns the filtered list of event tasks */
    ObservableList<ReadOnlyTask> getFilteredEventList();

```
###### \java\seedu\taskitty\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTodoList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        return model.getFilteredDeadlineList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredEventList() {
        return model.getFilteredEventList();
    }

```
###### \java\seedu\taskitty\logic\parser\CommandParser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        String messageParameter = Command.getAddCommandMessageParameter();
        // Validate arg string format
        if (!matcher.matches()) {
            return createNewIncorrectCommand(messageParameter);
        }
        try {
            String arguments = matcher.group("arguments");
            String taskDetailArguments = getTaskDetailArguments(arguments);
            String tagArguments = getTagArguments(arguments);

            return new AddCommand(extractTaskDetailsUsingNatty(taskDetailArguments),
                    getTagsFromArgs(tagArguments), args);
            
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses the argument to get a string of all the relevant details of the task
     * 
     * @param arguments command args string without command word
     */
    private String getTaskDetailArguments(String arguments) {
        int detailLastIndex = arguments.indexOf(Tag.TAG_PREFIX);
        if (detailLastIndex == NOT_FOUND) {
            detailLastIndex = arguments.length();
        }

        return arguments.substring(STRING_START, detailLastIndex).trim();
    }

    /**
     * Parses the argument to get a string of all tags, including the Tag prefix
     * 
     * @param arguments command args string without command word
     */
    private String getTagArguments(String arguments) {
        int tagStartIndex = arguments.indexOf(Tag.TAG_PREFIX);
        if (tagStartIndex == NOT_FOUND) {
            tagStartIndex = arguments.length();
        }

        return arguments.substring(tagStartIndex);
    }

    /**
     * Extracts the task details into a String array representing the name, date, time.
     * Details are arranged according to index shown in Task
     * 
     * @param dataArguments command args string with only name, date, time arguments
     */
    private String[] extractTaskDetailsUsingNatty(String dataArguments) {
        String nattyDataArguments = convertToNattyDateFormat(dataArguments);
        ArrayList<String> details = new ArrayList<String>();
        int nameEndIndex = nattyDataArguments.length();

        String dataArgumentsNameExtracted = extractNameInQuotes(nattyDataArguments, details);

        // if list is not empty at this point, it means that name was successfully extracted
        boolean isNameExtracted = !details.isEmpty();

        nameEndIndex = extractDateTimeUsingNatty(dataArgumentsNameExtracted, details);

        if (!isNameExtracted) {
            details.add(Task.TASK_COMPONENT_INDEX_NAME,
                    dataArgumentsNameExtracted.substring(STRING_START, nameEndIndex).trim());
        }

        String[] returnDetails = new String[details.size()];
        details.toArray(returnDetails);
        return returnDetails;
    }

    /**
     * Extracts the name from dataArguments if the name is surrounded by quotes.
     * Puts the extracted name into details
     * 
     * Returns a String with the name removed from dataArguments
     */
    private String extractNameInQuotes(String dataArguments, ArrayList<String> details) {
        String dataArgumentsAfterExtract;
        int quoteEndIndex = dataArguments.lastIndexOf(COMMAND_QUOTE_SYMBOL);
        if (quoteEndIndex != NOT_FOUND) {
            int nameStartIndex = dataArguments.indexOf(COMMAND_QUOTE_SYMBOL);
            if (nameStartIndex == NOT_FOUND) {
                nameStartIndex = STRING_START;
            }

            String nameDetail = dataArguments.substring(nameStartIndex, quoteEndIndex);

            // remove name from dataArguments
            dataArgumentsAfterExtract = dataArguments.replace(nameDetail, EMPTY_STRING);

            // remove quotes from nameDetail
            nameDetail = nameDetail.replaceAll(COMMAND_QUOTE_SYMBOL, EMPTY_STRING);

            details.add(Task.TASK_COMPONENT_INDEX_NAME, nameDetail);
        } else {
            dataArgumentsAfterExtract = dataArguments; // nothing is extracted
        }
        return dataArgumentsAfterExtract;
    }

    /**
     * Extracts the date and time using Natty
     * 
     * Returns the index where the task name should end.
     */
    private int extractDateTimeUsingNatty(String dataArguments, ArrayList<String> details) {
        List<DateGroup> dateGroups = nattyParser.parse(dataArguments);
        int nameEndIndex = dataArguments.length();

        for (DateGroup group : dateGroups) {
            List<Date> dates = group.getDates();
            // Natty's getPosition returns 1 based position
            // -1 because we want the 0 based position
            nameEndIndex = Math.min(nameEndIndex, group.getPosition() - 1);
            for (Date date : dates) {
                String nattyDate = extractLocalDate(date);
                String nattyTime = extractLocalTime(date);
                logger.info("Date Time extracted from natty: " + nattyDate + ", " + nattyTime);
                details.add(nattyDate);
                details.add(nattyTime);
            }
        }
        return nameEndIndex;
    }

```
###### \java\seedu\taskitty\logic\parser\CommandParser.java
``` java
    /**
     * Takes in a date from Natty and converts it into a string representing
     * date Format of date returned is according to TaskDate
     * 
     * @param date retrieved using Natty
     */
    private String extractLocalDate(Date date) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(TaskDate.DATE_FORMAT_STRING);
        return dateFormat.format(date);
    }

    /**
     * Takes in a date from Natty and converts it into a string representing
     * time Format of time returned is according to TaskTime
     * 
     * @param date retrieved using Natty
     */
    private String extractLocalTime(Date date) {
        if (isTimeApproxEqualToNow(date)) {
            // Natty parses the current time if string does not include time.
            // We want to ignore input when current time equal input time
            return null;
        }
        SimpleDateFormat timeFormat = new SimpleDateFormat(TaskTime.TIME_FORMAT_STRING);
        return timeFormat.format(date);

    }
    
    /**
     * Checks if the date given is approximately equal to the date now.
     * The date can be different by maximum of the time in milliseconds of TIME_APPROX_DELAY.
     */
    private boolean isTimeApproxEqualToNow(Date date) {
        assert date != null;
        SimpleDateFormat timeFormat = new SimpleDateFormat(TIME_APPROX);
        String currentTime = timeFormat.format(new Date());
        String inputTime = timeFormat.format(date);
        
        return currentTime.equals(inputTime);
    }

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays
                .asList(tagArguments.replaceFirst(Tag.TAG_PREFIX, EMPTY_STRING).split(Tag.TAG_PREFIX));
        return new HashSet<>(tagStrings);
    }

```
###### \java\seedu\taskitty\logic\ToolTip.java
``` java
public class ToolTip {

    public static final String TOOLTIP_DELIMITER = " | ";
    
    private static final int COMMAND_WORD_POSITION = 0;
    private static final String COMMAND_WORD_DELIMITER = "\\s+";

    private static final int COMMAND_WORD_COUNT_NO_MATCH = 0;
    private static final int COMMAND_WORD_COUNT_SINGLE_MATCH = 1;

    private static final String TOOLTIP_POSSIBLE_COMMANDS = "These are the possible commands, Meow!";
    private static final String TOOLTIP_UNKNOWN_COMMAND = "This does not resemble any command I have, Meow!";

    private static ToolTip tooltip;

    private FilteredList<String> commands;

    private String message;
    private String description;

    private ToolTip() {
        ObservableList<String> commandList = FXCollections.observableArrayList();
        commandList.addAll(Command.ALL_COMMAND_WORDS);
        commands = commandList.filtered(null);
        clearToolTip();
    }

    /**
     * Gets the instance of ToolTip to be used
     */
    public static ToolTip getInstance() {
        if (tooltip == null) {
            tooltip = new ToolTip();
        }
        return tooltip;
    }

    /**
     * Get the tooltip based on input
     * 
     * @param input to determine the tooltip to be shown
     */
    public void createToolTip(String input) {
        clearToolTip();
        String[] splitedInput = input.trim().split(COMMAND_WORD_DELIMITER);
        
        // only interested in the first word, which is the command word
        String command = splitedInput[COMMAND_WORD_POSITION];

        // filter the commands list to show only commands that match
        commands.setPredicate(p -> p.startsWith(command));

        if (!isCommandWordMatch()) {
            setToolTip(MESSAGE_UNKNOWN_COMMAND, TOOLTIP_UNKNOWN_COMMAND);
        } else if (isSingleMatchFound()) {
            getToolTipForCommand(command);
        } else {
            getToolTipForAllCommands();
        }
    }

    /**
     * Returns true if there is at least 1 command word that matches
     */
    private boolean isCommandWordMatch() {
        return commands.size() != COMMAND_WORD_COUNT_NO_MATCH;
    }

    /**
     * Returns true if there is exactly 1 command word that matches
     */
    private boolean isSingleMatchFound() {
        return commands.size() == COMMAND_WORD_COUNT_SINGLE_MATCH;
    }

    /**
     * Finds the closest matching command and returns the appropriate tooltip
     * 
     * @param command to determine which command tooltip to show
     */
    private void getToolTipForCommand(String command) {
        for (int i = 0; i < Command.ALL_COMMAND_WORDS.length; i++) {
            if (Command.ALL_COMMAND_WORDS[i].startsWith(command)) {
                setToolTip(Command.ALL_COMMAND_MESSAGE_PARAMETER[i], Command.ALL_COMMAND_MESSAGE_USAGE[i]);
                return;
            }
        }
        setToolTip(MESSAGE_UNKNOWN_COMMAND, TOOLTIP_UNKNOWN_COMMAND);
    }

    /**
     * Returns a string representing the matched input,
     * delimitered by TOOLTIP_DELIMITER
     */
    private void getToolTipForAllCommands() {
        assert commands.size() != COMMAND_WORD_COUNT_NO_MATCH && commands.size() != COMMAND_WORD_COUNT_SINGLE_MATCH;

        StringBuilder commandBuilder = new StringBuilder();

        commandBuilder.append(commands.get(0));
        for (int i = 1; i < commands.size(); i++) {
            commandBuilder.append(TOOLTIP_DELIMITER + commands.get(i));
        }

        setToolTip(commandBuilder.toString(), TOOLTIP_POSSIBLE_COMMANDS);
    }

    /**
     * Set the tooltip and description back to empty string
     */
    private void clearToolTip() {
        message = "";
        description = "";
    }

    public String getMessage() {
        return message;
    }

    public String getDescription() {
        return description;
    }
    
    /**
     * Returns true if user input is valid based on the latest tooltip generated
     */
    public boolean isUserInputValid() {
        return !isMessageUnknownOrEmpty();
    }
    
    /**
     * Returns true if the message of tooltip is null, empty or MESSAGE_UNKNOWN_COMMAND
     */
    private boolean isMessageUnknownOrEmpty() {
        return this.message == null
                || this.message.isEmpty()
                || this.message.equals(MESSAGE_UNKNOWN_COMMAND);
    }

    /**
     * Sets the tooltip and description to the given parameters
     */
    private void setToolTip(String tooltip, String description) {
        this.message = tooltip;
        this.description = description;
    }
}
```
###### \java\seedu\taskitty\model\Model.java
``` java
    /**
     * Returns the filtered todo task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTodoList();

    /**
     * Returns the filtered deadline task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList();

    /**
     * Returns the filtered event task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList();

```
###### \java\seedu\taskitty\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTodoList() {
        return new UnmodifiableObservableList<>(filteredTodos);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        return new UnmodifiableObservableList<>(filteredDeadlines);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList() {
        return new UnmodifiableObservableList<>(filteredEvents);
    }

```
###### \java\seedu\taskitty\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream().allMatch(keyword -> containsByType(task, keyword));
        }

        /**
         * Check if a task contains the given keyword. Tags will be used to
         * compare if keyword contains TAG_PREFIX Returns true if keyword is found in task
         * 
         * @param task to be checked
         * @param keyword to look for in task
         */
        private boolean containsByType(ReadOnlyTask task, String keyword) {
            assert task != null;
            assert keyword != null && !keyword.isEmpty();

            String toCompare = task.getName().fullName;
            if (keyword.contains(Tag.TAG_PREFIX)) {
                toCompare = task.tagsString();
            }
            return StringUtil.containsIgnoreCase(toCompare, keyword);
        }

```
###### \java\seedu\taskitty\model\task\ReadOnlyTask.java
``` java
/**
 * A read-only immutable interface for a Task in the taskmanager.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();
    TaskPeriod getPeriod();
    
```
###### \java\seedu\taskitty\model\task\ReadOnlyTask.java
``` java
    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getPeriod().equals(this.getPeriod()));
    }

    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        builder.append(getPeriod());
        builder.append(" " + tagsString());
        return builder.toString();
    }

```
###### \java\seedu\taskitty\model\task\Task.java
``` java
/**
 * Represents a Task in the taskManager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {
    
    public static final int TASK_COMPONENT_INDEX_NAME = 0;
    public static final int TASK_COMPONENT_COUNT = 1;
    
    public static final int DEADLINE_COMPONENT_INDEX_NAME = 0;
    public static final int DEADLINE_COMPONENT_INDEX_END_DATE = 1;
    public static final int DEADLINE_COMPONENT_INDEX_END_TIME = 2;
    public static final int DEADLINE_COMPONENT_COUNT = 3;
    
    public static final int EVENT_COMPONENT_INDEX_NAME = 0;
    public static final int EVENT_COMPONENT_INDEX_START_DATE = 1;
    public static final int EVENT_COMPONENT_INDEX_START_TIME = 2;
    public static final int EVENT_COMPONENT_INDEX_END_DATE = 3;
    public static final int EVENT_COMPONENT_INDEX_END_TIME = 4;
    public static final int EVENT_COMPONENT_COUNT = 5;
    
```
###### \java\seedu\taskitty\model\task\Task.java
``` java
    private Name name;
    private TaskPeriod period;
    private boolean isDone;
    private boolean isOverdue;

    private UniqueTagList tags;

    /**
     * Constructor for a Task.
     * The type of Task it is is dependent on the period given.
     * 
     * Every field must be present and not null.
     */
    public Task(Name name, TaskPeriod period, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, period, tags);
        
        this.name = name;
        this.period = period;
        this.tags = new UniqueTagList(tags);
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getPeriod(), source.getTags());
        this.isDone = source.getIsDone();
        this.isOverdue = source.isOverdue();
    }

    @Override
    public Name getName() {
        return name;
    }
    
    @Override
    public TaskPeriod getPeriod() {
        return period;
    }

```
###### \java\seedu\taskitty\model\task\TaskDate.java
``` java
/**
 * Represents a Task's date in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDateFormat(String)}
 */
public class TaskDate {

    public static final String MESSAGE_DATE_CONSTRAINTS =
            "Task dates should be in the format dd/mm/yyyy";
    public static final String MESSAGE_DATE_INVALID =
            "Task date provided is invalid!";
    public static final String MESSAGE_DATE_MISSING =
            "Task date must be provided";
    public static final String DATE_FORMAT_STRING = "dd/MM/yyyy";
    public static final DateTimeFormatter DATE_FORMATTER_STORAGE = DateTimeFormatter.ofPattern(DATE_FORMAT_STRING);
    public static final DateTimeFormatter DATE_FORMATTER_UI = DateTimeFormatter.ofPattern("E, dd MMM");
    
    //format: dd/mm/yyyy
    private static final String DATE_VALIDATION_REGEX = "[\\p{Digit}]{1,2}/[\\p{Digit}]{1,2}/[\\p{Digit}]{4}";

    private final LocalDate date;

    /**
     * Validates given date. The date should be parsed by Natty and
     * be in the format according to DATE_FORMAT_STRING
     *
     * @throws IllegalValueException if given date is invalid.
     */
    public TaskDate(String date) throws IllegalValueException {
        //date cannot be null after being parsed by natty
        assert date != null;
        
        String trimDate = date.trim();
        //This is not an assert because user can change the database and input wrong formats
        if (!isValidDateFormat(trimDate)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        
        try {
            this.date = LocalDate.parse(trimDate, DATE_FORMATTER_STORAGE);
        } catch (DateTimeParseException dtpe){
            throw new IllegalValueException(MESSAGE_DATE_INVALID);
        }
    }

    /**
     * Returns true if a given string is a valid date in DATE_FORMAT_STRING format.
     */
    public static boolean isValidDateFormat(String test) {
        return test.matches(DATE_VALIDATION_REGEX);
    }
    
    /**
     * Returns true if this TaskDate is before the given TaskDate.
     * 
     * @param date to be compared
     */
    public boolean isBefore(TaskDate date) {
        return this.date.isBefore(date.getDate());
    }

    @Override
    public String toString() {
        return date.format(DATE_FORMATTER_STORAGE);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && this.date.equals(((TaskDate) other).date)); // state check
    }
    
    /**
     * This method can be used when unsure which dates are null
     */
    public static boolean isEquals(TaskDate date, TaskDate other) {

        return (date == null && other == null) //if both are null, they are equal
                || date != null && date.equals(other);
    }

    public LocalDate getDate() {
        return date;
    }
}
```
###### \java\seedu\taskitty\model\task\TaskPeriod.java
``` java
/**
 * Represents a Task's startDate, startTime, endDate and endTime in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPeriod(String)}
 */
public class TaskPeriod implements Comparable<TaskPeriod>{

    public static final String MESSAGE_PERIOD_INVALID =
            "Task start datetime cannot be after end datetime!";

    private TaskDate startDate;
    private TaskTime startTime;
    private TaskDate endDate;
    private TaskTime endTime;
    private int numArgs;

    /**
     * Constructor for a "todo" TaskPeriod.
     * "todo" is a TaskPeriod no date and time.
     */
    public TaskPeriod() {
        numArgs = Task.TASK_COMPONENT_COUNT;
    }
    
    /**
     * Constructor for a "deadline" TaskPeriod.
     * "deadline" is a TaskPeriod with endDate and endTime.
     */
    public TaskPeriod(TaskDate endDate, TaskTime endTime) {
        assert !CollectionUtil.isAnyNull(endDate, endTime);
        
        this.endDate = endDate;
        this.endTime = endTime;
        numArgs = Task.DEADLINE_COMPONENT_COUNT;
    }
    
    /**
     * Constructor for a "event" TaskPeriod.
     * "event" is a TaskPeriod with all fields.
     * This constructor allows nulls and can be used when unsure which values are null
     *
     * @throws IllegalValueException if given start date/time is after end date/time.
     */
    public TaskPeriod(TaskDate startDate, TaskTime startTime,
                TaskDate endDate, TaskTime endTime) throws IllegalValueException {
        if (!isValidPeriod(startDate, startTime, endDate, endTime)) {
            throw new IllegalValueException(MESSAGE_PERIOD_INVALID);
        }
        
        this.startDate = startDate;
        this.startTime = startTime;
        this.endDate = endDate;
        this.endTime = endTime;
        
        if (this.startDate != null) {
            assert this.startTime != null;
            numArgs = Task.EVENT_COMPONENT_COUNT;
        } else if (this.endDate != null) {
            assert this.endTime != null;
            numArgs = Task.DEADLINE_COMPONENT_COUNT;
        } else {
            numArgs = Task.TASK_COMPONENT_COUNT;
        }
    }

    /**
     * Returns true if a given startDate, startTime, endDate, endTime form a valid period.
     * 
     * Valid period is where startDate, startTime cannot be later than endDate, endTime
     * If either startDate or endDate are null, return true because there is no period
     */
    public static boolean isValidPeriod(TaskDate startDate, TaskTime startTime,
            TaskDate endDate, TaskTime endTime) {
        
        boolean isValid = false;
        if (startDate == null || endDate == null) {
            isValid = true;
        } else if (startDate.isBefore(endDate)) {
            isValid = true;
        } else if (startDate.equals(endDate) && startTime.isBefore(endTime)) {
            isValid = true;
        }
        return isValid;
    }
    
    public int getNumArgs() {
        return numArgs;
    }
    
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        if (startDate != null) {
            builder.append(" from: ")
                    .append(startDate + " ")
                    .append(startTime)
                    .append(" to ")
                    .append(endDate + " ")
                    .append(endTime);
        } else if (endDate != null) {
            builder.append(" by ")
                .append(endDate + " ")
                .append(endTime);
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskPeriod // instanceof handles nulls
                && TaskDate.isEquals(((TaskPeriod) other).getStartDate(), this.getStartDate())
                && TaskTime.isEquals(((TaskPeriod) other).getStartTime(), this.getStartTime())
                && TaskDate.isEquals(((TaskPeriod) other).getEndDate(), this.getEndDate())
                && TaskTime.isEquals(((TaskPeriod) other).getEndTime(), this.getEndTime()));
    }
    
    public TaskDate getStartDate() {
        return startDate;
    }
    
    public TaskTime getStartTime() {
        return startTime;
    }
    
    public TaskDate getEndDate() {
        return endDate;
    }
    
    public TaskTime getEndTime() {
        return endTime;
    }
```
###### \java\seedu\taskitty\model\task\TaskTime.java
``` java
/**
 * Represents a Task's time in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidTimeFormat(String)}
 */
public class TaskTime {

    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Task time should be in the format hh:mm";
    public static final String MESSAGE_TIME_INVALID =
            "Task time provided is invalid!";
    public static final String MESSAGE_TIME_MISSING =
            "Task time must be provided";
    public static final String TIME_FORMAT_STRING = "HH:mm";
    public static final DateTimeFormatter TIME_FORMATTER_STORAGE = DateTimeFormatter.ofPattern(TIME_FORMAT_STRING);
    public static final DateTimeFormatter TIME_FORMATTER_UI = DateTimeFormatter.ofPattern("hh:mma");
    
    //format: hh:mm
    private static final String TIME_VALIDATION_FORMAT = "[\\p{Digit}]{1,2}:[\\p{Digit}]{2}";

    private final LocalTime time;

    /**
     * Validates given time. The time should be parsed by Natty and
     * be in the format according to TIME_FORMAT_STRING
     *
     * @throws IllegalValueException if given time is invalid or null.
     */
    public TaskTime(String time) throws IllegalValueException {
        if (time == null) {
            throw new IllegalValueException(MESSAGE_TIME_MISSING);
        }
        
        String trimTime = time.trim();
        //This is not an assert because user can change the database and input wrong formats
        if (!isValidTimeFormat(trimTime)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        
        try {
            this.time = LocalTime.parse(trimTime, TIME_FORMATTER_STORAGE);
        } catch (DateTimeParseException dtpe){
            throw new IllegalValueException(MESSAGE_TIME_INVALID);
        }
    }

    /**
     * Returns true if a given string is a valid time in TIME_FORMAT_STRING format.
     */
    public static boolean isValidTimeFormat(String test) {
        return test.matches(TIME_VALIDATION_FORMAT);
    }
    
    /**
     * Returns true if this TaskTime is before the given TaskTime.
     * 
     * @param time to be compared
     */
    public boolean isBefore(TaskTime time) {
        return this.time.isBefore(time.getTime());
    }

    @Override
    public String toString() {
        return time.format(TIME_FORMATTER_STORAGE);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instanceof handles nulls
                && this.time.equals(((TaskTime) other).time)); // state check
    }
    
    /**
     * This method can be used when unsure which times are null
     */
    public static boolean isEquals(TaskTime time, TaskTime other) {

        return (time == null && other == null) //if both are null, they are equal
                || time != null && time.equals(other);
    }

    public LocalTime getTime() {
        return time;
    }

}
```
###### \java\seedu\taskitty\model\task\UniqueTaskList.java
``` java
    /**
     * Filters the list based on the number of arguments the TaskPeriod has
     *   TODOS      : numArgs = Task.TASK_COMPONENT_COUNT
     *   DEADLINES  : numArgs = Task.DEADLINE_COMPONENT_COUNT
     *   EVENTS     : numArgs = Task.EVENT_COMPONENT_COUNT
     */
    public FilteredList<Task> getFilteredTaskList(int filter) {
        return internalList.filtered(p -> p.isNumArgsMatch(filter));
    }
    
```
###### \java\seedu\taskitty\model\TaskManager.java
``` java
    /**
     * Returns a task list filtered to only contain Todos
     */
    public ObservableList<Task> getFilteredTodos() {
        return tasks.getFilteredTaskList(Task.TASK_COMPONENT_COUNT);
    }
    
    /**
     * Returns a task list filtered to only contain Deadlines
     */
    public ObservableList<Task> getFilteredDeadlines() {
        return tasks.getFilteredTaskList(Task.DEADLINE_COMPONENT_COUNT);
    }
    
    /**
     * Returns a task list filtered to only contain Events
     */
    public ObservableList<Task> getFilteredEvents() {
        return tasks.getFilteredTaskList(Task.EVENT_COMPONENT_COUNT);
    }

```
###### \java\seedu\taskitty\storage\XmlAdaptedTask.java
``` java
package seedu.taskitty.storage;

import seedu.taskitty.commons.exceptions.IllegalValueException;
import seedu.taskitty.model.tag.Tag;
import seedu.taskitty.model.tag.UniqueTagList;
import seedu.taskitty.model.task.*;

import javax.xml.bind.annotation.XmlElement;
import java.util.ArrayList;
import java.util.List;

/**
 * JAXB-friendly version of the Person.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name;
    @XmlElement
    private String startDate;
    @XmlElement
    private String endDate;
    @XmlElement
    private String startTime;
    @XmlElement
    private String endTime;
    @XmlElement
    private boolean isDone;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        TaskDate sourceStartDate = source.getPeriod().getStartDate();
        TaskDate sourceEndDate = source.getPeriod().getEndDate();
        TaskTime sourceStartTime = source.getPeriod().getStartTime();
        TaskTime sourceEndTime = source.getPeriod().getEndTime();
        
        if (sourceStartDate != null) {
            startDate = sourceStartDate.toString();
        }
        if (sourceEndDate != null) {
            endDate = sourceEndDate.toString();
        }
        if (sourceStartTime != null) {
            startTime = sourceStartTime.toString();
        }
        if (sourceEndTime != null) {
            endTime = sourceEndTime.toString();
        }
        isDone = source.getIsDone();
        
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        
        TaskDate startDate = null;
        if (this.startDate != null) {
            startDate = new TaskDate(this.startDate);
        }
        
        TaskDate endDate = null;
        if (this.endDate != null) {
            endDate = new TaskDate(this.endDate);
        }
        
        TaskTime startTime = null;
        if (this.startTime != null) {
            startTime = new TaskTime(this.startTime);
        }
        
        TaskTime endTime = null;
        if (this.endTime != null) {
            endTime = new TaskTime(this.endTime);
        }
        final UniqueTagList tags = new UniqueTagList(taskTags);
        
        Task task = new Task(name, new TaskPeriod(startDate, startTime, endDate, endTime), tags);
        
        if (isDone) {
            task.markAsDone();
        }
        
        return task;
    }
    
```
###### \java\seedu\taskitty\ui\CommandBox.java
``` java
    /**
     * Creates a text listener to listen on user input into textbox
     * and give appropriate feedback using the ToolTip class.
     */
    private void setTooltipListener() {
        commandTextField.textProperty().addListener((observable, oldValue, newValue) -> {
            EventsCenter.getInstance().post(new ShowToolTipEvent(newValue));
        });
    }
    
```
###### \java\seedu\taskitty\ui\CommandBox.java
``` java
    @Subscribe
    private void handleShowToolTip(ShowToolTipEvent event) {
        resultDisplay.postMessage(event.getToolTipMessage(), event.getToolTipDescription());
        
        boolean isCorrect = event.isUserInputValid() && isInputValid;
        if (isCorrect) {
            setStyleToIndicateCorrectCommand();
        } else {
            setStyleToIndicateIncorrectCommand();
        }
    }
    
    /**
     * Save the most recent command and empty the command box text
     */
    private void emptyCommandText(String command) {
        commandTextField.setText("");
        mostRecentResult = logic.execute(command);
    }
    
    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        setCatImage(ResultDisplay.IMAGE_CAT_NORMAL);
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandText);
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        if (!commandTextField.getStyleClass().contains("error")) {
            commandTextField.getStyleClass().add("error"); 
            setCatImage(ResultDisplay.IMAGE_CAT_SAD);
        }
    }
    
    private void setCatImage(String imagePath) {
        catImage.setImage(AppUtil.getImage(imagePath));
    }

}
```
###### \java\seedu\taskitty\ui\ResultDisplay.java
``` java
    /**
     * Prints the given message onto the Result Display without description
     */
    public void postMessage(String message) {
        toolTipLabel.setText(message);
        descriptionLabel.setText("");
    }
    
    /**
     * Prints the given message onto the Result Display with description
     */
    public void postMessage(String message, String description) {
        toolTipLabel.setText(message);
        descriptionLabel.setText(description);
    }
    
```
###### \java\seedu\taskitty\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
        
        if (task.isTodo()) {
            initializeTodo();
        } else if (task.isDeadline()) {
            initializeDeadline();
        } else if (task.isEvent()) {
            initializeEvent();
        } else {
            assert false : "Task has to be either todo, deadline or event";
        }
    }
    
    /**
     * Initializes the todo card to the correct state.
     * 
     * The resulting card will have id, name and tags.
     * If the task is done, panel will use .done css.
     */
    private void initializeTodo() {
        displayBasicTask(INDEX_PREFIX_TODO);
        hideStartDateTime();
        hideEndDateTime();
        setCardGridDateTimeColumnWidth(COLUMN_DATETIME_SIZE_TODO);
        
```
###### \java\seedu\taskitty\ui\TaskCard.java
``` java
    /**
     * Initializes the deadline card to the correct state.
     * 
     * The resulting card will have id, name, tags, end date-time.
     * If the task is done, panel will use .done css.
     * If the task is overdue, panel will use .overdue css.
     */
    private void initializeDeadline() {
        displayBasicTask(INDEX_PREFIX_DEADLINE);
        displayEndDateTime();
        hideStartDateTime();
        setCardGridDateTimeColumnWidth(COLUMN_DATETIME_SIZE_DEADLINE);
        
```
###### \java\seedu\taskitty\ui\TaskCard.java
``` java
    /**
     * Initializes the event card to the correct state.
     * 
     * The resulting card will have id, name, tags, start date-time and end date-time .
     * If the task is done, panel will use .done css.
     */
    private void initializeEvent() {
        displayBasicTask(INDEX_PREFIX_EVENT);
        displayStartDateTime();
        displayEndDateTime();
        
```
###### \java\seedu\taskitty\ui\TaskCard.java
``` java
    /**
     * Shows the common elements of all tasks on the UI: id, name and tags.
     * 
     * @param indexPrefix to correctly display the index of the task
     */
    private void displayBasicTask(String indexPrefix) {  
        name.setText(task.getName().fullName);
        id.setText(indexPrefix + displayedIndex);
        tags.setText(task.tagsString());
    }
    
    /**
     * Shows the start date-time of the task on the UI
     */
    private void displayStartDateTime() {
        TaskDate startTaskDate = task.getPeriod().getStartDate();
        TaskTime startTaskTime = task.getPeriod().getStartTime();
        startTime.setText(DateTimeUtil.formatTimeForUI(startTaskTime));
        startDate.setText(DateTimeUtil.formatDateForUI(startTaskDate));
    }
    
    /**
     * Shows the end date-time of the task on the UI
     */
    private void displayEndDateTime() {
        TaskDate endTaskDate = task.getPeriod().getEndDate();  
        TaskTime endTaskTime = task.getPeriod().getEndTime();
        endTime.setText(DateTimeUtil.formatTimeForUI(endTaskTime));
        endDate.setText(DateTimeUtil.formatDateForUI(endTaskDate));
    }
    
    /**
     * Removes the start date-time from the display
     */
    private void hideStartDateTime() {
        startTime.setManaged(false);
        startDate.setManaged(false);
        toLabel.setManaged(false);
    }
    
    /**
     * Removes the start and end date-time from the display
     */
    private void hideEndDateTime() {
        endTime.setManaged(false);
        endDate.setManaged(false);
    }
    
    /**
     * Adjusts the width of the date-time column of the card to the specified width
     */
    private void setCardGridDateTimeColumnWidth(int width) {
        cardGrid.getColumnConstraints().get(COLUMN_DATETIME).setMinWidth(width);
        cardGrid.getColumnConstraints().get(COLUMN_DATETIME).setPrefWidth(width);
        cardGrid.getColumnConstraints().get(COLUMN_DATETIME).setMaxWidth(width);
    }

```
###### \java\seedu\taskitty\ui\TaskListPanel.java
``` java
    private static final String ID_TODO = "todoListView";
    private static final String ID_DEADLINE = "deadlineListView";
    private static final String ID_EVENT = "eventListView";
    
    private static final String HEADER_TODO = "TODOS";
    private static final String HEADER_DEADLINE = "DEADLINES";
    private static final String HEADER_EVENT = "EVENTS";
    
    private static final String ICON_TODO = "/images/todo_icon.png";
    private static final String ICON_DEADLINE = "/images/deadline_icon.png";
    private static final String ICON_EVENT = "/images/event_icon.png";
    
```
###### \java\seedu\taskitty\ui\TaskListPanel.java
``` java
    /**
     * Initializes the list view header and ID depending on the type of list it is
     */
    private void initializeListView(int type) {
        
        switch (type) {
        
        case Task.TASK_COMPONENT_COUNT :
            setListUIComponents(HEADER_TODO, ICON_TODO, ID_TODO);
            break;
            
        case Task.DEADLINE_COMPONENT_COUNT :
            setListUIComponents(HEADER_DEADLINE, ICON_DEADLINE, ID_DEADLINE);
            break;
            
        case Task.EVENT_COMPONENT_COUNT :
            setListUIComponents(HEADER_EVENT, ICON_EVENT, ID_EVENT);
            break;
            
        default :
            assert false : "List must be either todo, deadline or event";
            break;
        }
    }
    
    /**
     * Sets the relevant UI components of the TaskListPanel based on input Strings
     * @param header title of the TaskListPanel
     * @param icon filepath to the image for the TaskListPanel's icon
     * @param id of the TaskListPanel. id must be set to use GuiRobot for testing
     */
    private void setListUIComponents(String header, String icon, String id) {
        this.header.setText(header);
        this.listIcon.setImage(AppUtil.getImage(icon));
        this.taskListView.setId(id);
    }
    
```
###### \resources\view\DarkTheme.css
``` css
.text-field {
    -fx-font-size: 13pt;
    -fx-font-family: "Helvetica";
}

.label-tooltip {
    -fx-font-size: 13pt;
    -fx-text-fill: black;
    -fx-opacity: 1;
}

.label-description {
    -fx-font-size: 11pt;
    -fx-text-fill: #555555;
    -fx-opacity: 0.8;
}

.split-pane .split-pane-divider {
    -fx-border-color: transparent;
    -fx-background-color: transparent;
}

.split-pane {
    -fx-border-radius: 1;
    -fx-border-width: 1;
    -fx-background-color: derive(#1d1d1d, 40%);
}

.list-view {
    -fx-background-color: transparent;
    -fx-border-width: 3 0 0 0;
    -fx-border-color: grey;
}

.list-cell:filled:selected:focused, .list-cell:filled:selected {
    -fx-background-color: transparent;
}

.list-cell {
    -fx-background-color: transparent;
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 1 0 0 0;
}

.cell_big_label {
    -fx-font-size: 20px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_tag_label {
    -fx-font-size: 14px;
    -fx-text-fill: #555555;
}

.result-display {
    -fx-background-color: #ffffff;
    -fx-border-radius: 10 10 10 10;
    -fx-background-radius: 10 10 10 10;
}

#cardPane{
    -fx-background-color: derive(grey, 80%);
    -fx-padding: 10 10 10 10;
    -fx-background-radius: 5;
    -fx-border-color: #d6d6d6;
    -fx-border-width: 0 0 0 0;
}

.pane-title {
    -fx-text-fill: #f9f9f9;
    -fx-font-size: 16px;
    -fx-font-weight: bold;
}

.error {
    -fx-background-color: #d9534f
}

```
###### \resources\view\ResultDisplay.fxml
``` fxml

<AnchorPane fx:id="resultDisplayArea" styleClass="anchor-pane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.taskitty.ui.ResultDisplay">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <Polygon fill="WHITE" layoutX="35.0" layoutY="55.0" rotate="120.0" scaleX="0.5" scaleY="0.5" stroke="WHITE" strokeType="INSIDE" styleClass="anchor-pane">
            <points>
                <Double fx:value="-50.0" />
                <Double fx:value="40.0" />
                <Double fx:value="50.0" />
                <Double fx:value="40.0" />
                <Double fx:value="0.0" />
                <Double fx:value="-60.0" />
            </points>
        </Polygon>
        <VBox layoutY="15.0" styleClass="result-display" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="15.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
            <children>
                <Label fx:id="toolTipLabel" styleClass="label-tooltip" text="\$tooltip" VBox.vgrow="ALWAYS" />
                <Label fx:id="descriptionLabel" styleClass="label-description" text="\$description" />
            </children>
            <padding>
                <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
            </padding>
        </VBox>
    </children>
</AnchorPane>
```
###### \resources\view\TaskListCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" maxHeight="80.0" minHeight="80.0"
    prefHeight="80.0" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65"
    xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane fx:id="cardGrid" HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="NEVER" maxWidth="50.0"
                    minWidth="50.0" prefWidth="50.0" />
                <ColumnConstraints hgrow="ALWAYS" minWidth="125.0"
                    prefWidth="125.0" />
                <ColumnConstraints halignment="RIGHT" hgrow="NEVER"
                    maxWidth="250.0" minWidth="250.0" prefWidth="250.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" GridPane.columnIndex="1"
                    GridPane.vgrow="ALWAYS">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>

                    <children>
                        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
                        <Label fx:id="tags" styleClass="cell_tag_label" text="\$tags">
                            <padding>
                                <Insets top="5.0" />
                            </padding>
                        </Label>
                    </children>
                </VBox>
                <HBox GridPane.columnIndex="2">
                    <children>
                        <VBox alignment="CENTER_LEFT">
                            <children>
                                <Label fx:id="startTime" ellipsisString="" styleClass="cell_big_label"
                                    text="\$startTime">
                                    <padding>
                                        <Insets left="5.0" />
                                    </padding>
                                </Label>
                                <Label fx:id="startDate" ellipsisString="" styleClass="cell_small_label"
                                    text="\$startDate">
                                    <padding>
                                        <Insets left="5.0" />
                                    </padding>
                                </Label>
                            </children>
                            <padding>
                                <Insets bottom="10.0" top="5.0" />
                            </padding>
                        </VBox>
                        <Label fx:id="toLabel" styleClass="cell_big_label" text="to">
                            <padding>
                                <Insets left="15.0" right="10.0" top="5.0" />
                            </padding>
                        </Label>
                        <VBox alignment="CENTER_LEFT">
                            <children>
                                <Label fx:id="endTime" ellipsisString="" styleClass="cell_big_label"
                                    text="\$endTime">
                                    <padding>
                                        <Insets left="5.0" />
                                    </padding>
                                </Label>
                                <Label fx:id="endDate" ellipsisString="" styleClass="cell_small_label"
                                    text="\$endDate">
                                    <padding>
                                        <Insets left="5.0" />
                                    </padding>
                                </Label>
                            </children>
                            <padding>
                                <Insets bottom="10.0" top="5.0" />
                            </padding>
                        </VBox>
                    </children>
                </HBox>
                <HBox alignment="TOP_CENTER">
                    <GridPane.margin>
                        <Insets />
                    </GridPane.margin>
                    <children>
                        <Label fx:id="id" ellipsisString="" styleClass="cell_big_label"
                            text="\$id" />
                    </children>
                    <padding>
                        <Insets top="7.0" />
                    </padding>
                </HBox>
            </children>
            <rowConstraints>
                <RowConstraints />
            </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
